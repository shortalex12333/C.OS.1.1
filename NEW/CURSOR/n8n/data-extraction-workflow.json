{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "async-processor",
        "options": {}
      },
      "name": "Async Entry1",
      "type": "n8n-nodes-base.webhook",
      "position": [
        580,
        -380
      ],
      "id": "f932ed79-6cf4-4ecc-b679-79de6bbbb4c9",
      "typeVersion": 2,
      "webhookId": "async-processor"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        360,
        -580
      ],
      "id": "882ec967-66ef-4319-80b0-d0085a7324f9",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * \nFROM conversations \nWHERE user_id = '{{ $json.body.userID }}' \n AND message IS NOT NULL\n AND ai_reply IS NOT NULL\nORDER BY created_at DESC \nLIMIT 1 OFFSET 1",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        140,
        -580
      ],
      "id": "58bf8d15-e7b5-4f9b-9102-3ab032adaed4",
      "name": "Postgres",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Fixed Insert Recent Interactions Query\nINSERT INTO recent_interactions (\n  user_id, \n  session_id, \n  interaction_type, \n  content, \n  category,\n  pattern_detected,\n  metadata, \n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.session_id ? \"'\" + $json.session_id.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.interaction_type ? \"'\" + $json.interaction_type.replace(/'/g, \"''\") + \"'\" : \"'text-chat'\" }},\n  {{ $json.content ? \"'\" + $json.content.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.category ? \"'\" + $json.category.replace(/'/g, \"''\") + \"'\" : \"'general'\" }},\n  {{ $json.pattern_detected ? \"'\" + $json.pattern_detected.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.metadata ? \"'\" + JSON.stringify($json.metadata).replace(/'/g, \"''\") + \"'::jsonb\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + JSON.stringify($json.emotional_signals).replace(/'/g, \"''\") + \"'::jsonb\" : \"'[]'::jsonb\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -3100
      ],
      "id": "13b1618e-89c5-4e54-81da-1538c7fe59cd",
      "name": "Insert Recent Interactions",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Collect all successful insertions\nconst results = $input.all();\n\n// Create a summary of what was inserted\nconst summary = {\n  total_operations: results.length,\n  successful_inserts: results.filter(r => r.json && r.json.user_id).length,\n  tables_processed: [],\n  timestamp: new Date().toISOString()\n};\n\n// Extract table names from successful operations\nresults.forEach(result => {\n  if (result.json && result.json.user_id) {\n    // Try to infer table from the data structure\n    if (result.json.message && result.json.ai_reply) {\n      summary.tables_processed.push('conversations');\n    } else if (result.json.interaction_type && result.json.content) {\n      summary.tables_processed.push('recent_interactions');\n    }\n    // Add more table detection logic as needed\n  }\n});\n\n// Remove duplicates\nsummary.tables_processed = [...new Set(summary.tables_processed)];\n\nreturn summary;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        -520
      ],
      "id": "55c6ca40-beea-4b47-9e5d-669510e42b07",
      "name": "Create Summary"
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        1780,
        -920
      ],
      "id": "6f4f36b8-5717-4103-b19c-aa7a8efd922f",
      "name": "Merge1"
    },
    {
      "parameters": {
        "numberInputs": 10
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        1780,
        -520
      ],
      "id": "969efc84-8a8f-452e-ad98-6add74dddbd4",
      "name": "Merge2"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        2020,
        -520
      ],
      "id": "3a6c3564-d14e-4832-8a17-5422ea8f8ca5",
      "name": "Merge3"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction extractHealthMetrics(text) {\n  const health = {\n    sleep_hours: null,\n    sleep_quality: null,\n    stress_level: null,\n    caffeine_intake: null,\n    water_liters: null,\n    meals_count: null,\n    energy_crashes: null,\n    mental_clarity: null\n  };\n  \n  // Sleep extraction\n  const sleepPatterns = [\n    /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)\\s*(?:of\\s*)?sleep/i,\n    /slept\\s*(?:for\\s*)?(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)/i,\n    /got\\s*(?:only\\s*)?(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)/i,\n    /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)\\s*last night/i\n  ];\n  \n  for (const pattern of sleepPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      health.sleep_hours = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Sleep quality from context\n  if (text.match(/\\b(terrible|awful|bad|poor)\\s*(sleep|night)/i)) health.sleep_quality = 2;\n  else if (text.match(/\\b(great|excellent|good|well)\\s*(sleep|night)/i)) health.sleep_quality = 8;\n  else if (text.match(/\\b(okay|decent|fine)\\s*(sleep|night)/i)) health.sleep_quality = 5;\n  else if (health.sleep_hours && health.sleep_hours < 5) health.sleep_quality = 3;\n  else if (health.sleep_hours && health.sleep_hours > 8) health.sleep_quality = 7;\n  \n  // Stress level extraction - MUST CATCH \"stress level is at 9\"\n  const stressPatterns = [\n    /stress\\s*(?:level\\s*)?(?:is\\s*)?(?:at\\s*)?(\\d+)/i,\n    /(\\d+)(?:\\/10)?\\s*stress/i,\n    /stress.*?(\\d+)/i\n  ];\n  \n  for (const pattern of stressPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      health.stress_level = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Contextual stress detection\n  if (!health.stress_level) {\n    if (text.match(/\\b(overwhelmed|breaking point|can't handle)\\b/i)) health.stress_level = 9;\n    else if (text.match(/\\b(very stressed|extremely stressed|so stressed)\\b/i)) health.stress_level = 8;\n    else if (text.match(/\\b(stressed|anxious|pressure)\\b/i)) health.stress_level = 7;\n    else if (text.match(/\\b(calm|relaxed|peaceful)\\b/i)) health.stress_level = 3;\n  }\n  \n  // Caffeine extraction - MUST CATCH \"5 coffees\"\n  const caffeinePatterns = [\n    /(\\d+)\\s*(?:cups?\\s*of\\s*)?(?:coffee|espresso|latte|cappuccino|caffeine)/i,\n    /had\\s*(\\d+)\\s*coffee/i,\n    /coffee.*?(\\d+)/i\n  ];\n  \n  for (const pattern of caffeinePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      health.caffeine_intake = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Water intake\n  const waterPatterns = [\n    /(\\d+(?:\\.\\d+)?)\\s*(?:liters?|litres?|l)\\s*(?:of\\s*)?water/i,\n    /drank\\s*(\\d+(?:\\.\\d+)?)\\s*(?:liters?|litres?)/i,\n    /(\\d+)\\s*(?:glasses?|cups?)\\s*(?:of\\s*)?water/i\n  ];\n  \n  for (const pattern of waterPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      if (match[0].includes('glass') || match[0].includes('cup')) {\n        health.water_liters = parseFloat(match[1]) * 0.25; // assume 250ml per glass\n      } else {\n        health.water_liters = parseFloat(match[1]);\n      }\n      break;\n    }\n  }\n  \n  // Meal counting\n  const meals = [];\n  if (text.match(/\\bbreakfast\\b/i)) meals.push('breakfast');\n  if (text.match(/\\blunch\\b/i)) meals.push('lunch');\n  if (text.match(/\\bdinner\\b/i)) meals.push('dinner');\n  if (text.match(/\\bsnack/i)) meals.push('snack');\n  \n  // Check for skipped meals\n  const skippedPattern = /(?:skipped|missed|no)\\s*(breakfast|lunch|dinner)/gi;\n  const skippedMatches = [...text.matchAll(skippedPattern)];\n  for (const match of skippedMatches) {\n    const index = meals.indexOf(match[1].toLowerCase());\n    if (index > -1) meals.splice(index, 1);\n  }\n  \n  health.meals_count = meals.length || null;\n  \n  // Energy crashes\n  if (text.match(/\\b(crash|crashed|energy dip|afternoon slump|3\\s*pm\\s*slump)\\b/i)) {\n    if (text.match(/\\bafternoon|3\\s*pm|after lunch\\b/i)) health.energy_crashes = 'afternoon';\n    else if (text.match(/\\bmorning\\b/i)) health.energy_crashes = 'morning';\n    else health.energy_crashes = 'yes';\n  }\n  \n  // Mental clarity\n  if (text.match(/\\b(focused|sharp|clear|productive)\\b/i)) health.mental_clarity = 8;\n  else if (text.match(/\\b(foggy|fuzzy|confused|scattered)\\b/i)) health.mental_clarity = 3;\n  else if (text.match(/\\b(okay|decent|manageable)\\b/i)) health.mental_clarity = 5;\n  \n  return health;\n}\n\nconst userInput = data.user_input || '';\nconst healthData = extractHealthMetrics(userInput);\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Merge extracted data with router data\nconst sleepHours = data.sleep_hours || healthData.sleep_hours;\nconst stressLevel = data.stress_level || healthData.stress_level;\nconst caffeineIntake = data.caffeine_intake || healthData.caffeine_intake;\n\n// Calculate confidence\nlet confidence = data.confidence_level || 0.5;\nif (sleepHours && stressLevel && caffeineIntake) confidence = 0.9;\nelse if ((sleepHours && stressLevel) || (sleepHours && caffeineIntake)) confidence = 0.8;\nelse if (sleepHours || stressLevel || caffeineIntake) confidence = 0.7;\n\nreturn {\n  user_input: data.user_input || null,\n  SleepHours: sleepHours,\n  'Calorie intake': parseFloat(data.calorie_intake || data.calories) || null,\n  'Vitamin intake': data.vitamin_intake || data.vitamins || data.supplements || null,\n  sleep_hours: sleepHours,\n  sleep_quality: healthData.sleep_quality || parseFloat(data.sleep_quality) || null,\n  meals_count: healthData.meals_count || parseFloat(data.meals_count) || null,\n  water_liters: healthData.water_liters || parseFloat(data.water_liters) || null,\n  caffeine_intake: caffeineIntake,\n  stress_level: stressLevel,\n  screen_time_hours: parseFloat(data.screen_time_hours || data.screen_time) || null,\n  energy_crashes: healthData.energy_crashes || data.energy_crashes || null,\n  took_breaks: data.took_breaks !== undefined ? data.took_breaks : null,\n  mental_clarity: healthData.mental_clarity || parseFloat(data.mental_clarity) || null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -2120
      ],
      "id": "5b7454e4-c02d-485f-b04f-86d6bf02e392",
      "name": "Prepare Health"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction extractGoalMetrics(text) {\n  const goal = {\n    target_value: null,\n    current_value: null,\n    deadline: null,\n    unit_of_measurement: null,\n    goal_type: null\n  };\n  \n  // Money patterns - MUST CATCH \"$30k\" and \"currently at $18k\"\n  const moneyPatterns = [\n    /(?:goal|target|aiming for|need|want)\\s*(?:is\\s*)?(?:to\\s*)?(?:hit|reach|make|earn)?\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /\\$(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:revenue|sales|income|profit)/i,\n    /(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:dollars|usd|\\$)/i\n  ];\n  \n  for (const pattern of moneyPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let value = match[1].replace(/,/g, '');\n      if (value.includes('k')) value = parseFloat(value.replace('k', '')) * 1000;\n      else if (value.includes('m')) value = parseFloat(value.replace('m', '')) * 1000000;\n      else value = parseFloat(value);\n      goal.target_value = value;\n      goal.unit_of_measurement = 'dollars';\n      goal.goal_type = 'financial';\n      break;\n    }\n  }\n  \n  // Current value extraction\n  const currentPatterns = [\n    /currently\\s*(?:at|have|earned|made)?\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /(?:so far|already|now)\\s*(?:at|have)?\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /(?:at|have)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:now|already|so far)/i\n  ];\n  \n  for (const pattern of currentPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let value = match[1].replace(/,/g, '');\n      if (value.includes('k')) value = parseFloat(value.replace('k', '')) * 1000;\n      else if (value.includes('m')) value = parseFloat(value.replace('m', '')) * 1000000;\n      else value = parseFloat(value);\n      goal.current_value = value.toString();\n      break;\n    }\n  }\n  \n  // Deadline extraction - MUST CATCH \"end of month\"\n  const dateTime = extractDateTime(text);\n  if (dateTime.date) {\n    goal.deadline = dateTime.date;\n  }\n  \n  // Additional deadline patterns\n  if (!goal.deadline) {\n    const deadlinePatterns = {\n      'by end of month': () => {\n        const d = new Date();\n        d.setMonth(d.getMonth() + 1);\n        d.setDate(0);\n        return d.toISOString().split('T')[0];\n      },\n      'this month': () => {\n        const d = new Date();\n        d.setMonth(d.getMonth() + 1);\n        d.setDate(0);\n        return d.toISOString().split('T')[0];\n      },\n      'this week': () => {\n        const d = new Date();\n        const day = d.getDay();\n        const diff = 7 - day;\n        d.setDate(d.getDate() + diff);\n        return d.toISOString().split('T')[0];\n      },\n      'this year': () => {\n        const d = new Date();\n        d.setMonth(11);\n        d.setDate(31);\n        return d.toISOString().split('T')[0];\n      },\n      'by next month': () => {\n        const d = new Date();\n        d.setMonth(d.getMonth() + 2);\n        d.setDate(0);\n        return d.toISOString().split('T')[0];\n      }\n    };\n    \n    for (const [phrase, dateFunc] of Object.entries(deadlinePatterns)) {\n      if (text.toLowerCase().includes(phrase)) {\n        goal.deadline = dateFunc();\n        break;\n      }\n    }\n  }\n  \n  // Goal type detection\n  if (!goal.goal_type) {\n    if (text.match(/\\b(revenue|sales|income|profit|money|financial|earn)\\b/i)) {\n      goal.goal_type = 'financial';\n    } else if (text.match(/\\b(weight|health|fitness|workout|exercise)\\b/i)) {\n      goal.goal_type = 'health';\n    } else if (text.match(/\\b(customer|client|user|subscriber)\\b/i)) {\n      goal.goal_type = 'business';\n    } else if (text.match(/\\b(product|launch|ship|release|build)\\b/i)) {\n      goal.goal_type = 'product';\n    } else if (text.match(/\\b(habit|routine|daily|weekly)\\b/i)) {\n      goal.goal_type = 'habits';\n    }\n  }\n  \n  return goal;\n}\n\nconst userInput = data.user_input || '';\nconst goalData = extractGoalMetrics(userInput);\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Priority calculation based on urgency and emotions\nlet priority = parseInt(data.priority) || 3;\nif (emotions.includes('anxious') || emotions.includes('stressed')) priority = 1;\nelse if (emotions.includes('motivated') || emotions.includes('determined')) priority = 2;\nelse if (goalData.deadline) {\n  const daysUntilDeadline = Math.floor((new Date(goalData.deadline) - new Date()) / (1000 * 60 * 60 * 24));\n  if (daysUntilDeadline < 7) priority = 1;\n  else if (daysUntilDeadline < 30) priority = 2;\n}\n\n// Confidence calculation\nlet confidence = data.confidence_level || 0.5;\nif (goalData.target_value && goalData.deadline && goalData.current_value) confidence = 0.95;\nelse if (goalData.target_value && (goalData.deadline || goalData.current_value)) confidence = 0.85;\nelse if (goalData.target_value) confidence = 0.75;\n\nreturn {\n  user_input: data.user_input || null,\n  target_value: goalData.target_value || parseFloat(data.target_value) || null,\n  unit_of_measurement: goalData.unit_of_measurement || data.unit_of_measurement || null,\n  goal_type: goalData.goal_type || data.goal_type || null,\n  current_value: goalData.current_value || data.current_value || null,\n  deadline: goalData.deadline || data.deadline || null,\n  priority: priority,\n  status: data.status || 'active',\n  active_goals: data.active_goals || data.goal_text || null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1320
      ],
      "id": "9f21dec0-26cc-452e-bf13-8e44b9ff0584",
      "name": "Prepare Goals"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction extractInsecurities(text) {\n  const insecurities = [];\n  \n  const insecurityPatterns = {\n    imposter_syndrome: /\\b(imposter|fraud|fake|not qualified|don't belong|pretending)\\b/i,\n    self_doubt: /\\b(not good enough|never enough|can't do|incapable|incompetent)\\b/i,\n    comparison: /\\b(everyone else|others are better|behind|falling behind|not as good)\\b/i,\n    perfectionism: /\\b(not perfect|mistakes|flawed|failure|mess up)\\b/i,\n    abandonment: /\\b(leave me|abandon|alone|nobody cares|forgotten)\\b/i,\n    rejection: /\\b(reject|unwanted|don't like me|hate me|push away)\\b/i,\n    inadequacy: /\\b(inadequate|insufficient|lacking|missing|not enough)\\b/i,\n    shame: /\\b(ashamed|embarrassed|humiliated|disgrace|shameful)\\b/i\n  };\n  \n  for (const [insecurity, pattern] of Object.entries(insecurityPatterns)) {\n    if (pattern.test(text)) {\n      insecurities.push(insecurity.replace(/_/g, ' '));\n    }\n  }\n  \n  // Deep linguistic analysis for implicit insecurities\n  if (text.match(/\\b(I'm|i am)\\s+(always|never|just|only)\\b/i)) {\n    insecurities.push('fixed mindset');\n  }\n  \n  if (text.match(/\\b(should|supposed to|meant to|have to)\\b/gi)?.length > 2) {\n    insecurities.push('external validation seeking');\n  }\n  \n  if (text.match(/\\bbut\\s*(I'm|i am|I|i)\\s*(not|can't|don't)\\b/i)) {\n    insecurities.push('self-limiting beliefs');\n  }\n  \n  return insecurities;\n}\n\nfunction extractFears(text) {\n  const fears = [];\n  \n  const fearPatterns = {\n    failure: /\\b(fail|failure|failing|unsuccessful|not succeed)\\b/i,\n    success: /\\b(success|succeed|achieving|what if I make it)\\b/i,\n    judgment: /\\b(judge|judged|criticism|criticize|what.*think)\\b/i,\n    rejection: /\\b(reject|rejection|turn down|say no|declined)\\b/i,\n    abandonment: /\\b(leave|abandon|alone|lost|lose them)\\b/i,\n    inadequacy: /\\b(not enough|inadequate|insufficient|lacking)\\b/i,\n    unknown: /\\b(unknown|uncertain|don't know what|unpredictable)\\b/i,\n    loss: /\\b(lose|loss|losing|lost|gone)\\b/i,\n    change: /\\b(change|different|new|unfamiliar)\\b/i,\n    commitment: /\\b(commit|commitment|trapped|stuck with)\\b/i,\n    exposure: /\\b(exposed|found out|discover|reveal)\\b/i,\n    poverty: /\\b(broke|poor|no money|bankrupt|financial ruin)\\b/i\n  };\n  \n  for (const [fear, pattern] of Object.entries(fearPatterns)) {\n    if (pattern.test(text)) {\n      fears.push(fear);\n    }\n  }\n  \n  // Context-specific fear detection\n  if (text.match(/\\bafraid\\s*(of|that|to)\\s*(\\w+)/i)) {\n    const match = text.match(/\\bafraid\\s*(of|that|to)\\s*(\\w+)/i);\n    if (match && !fears.includes(match[2])) {\n      fears.push(match[2]);\n    }\n  }\n  \n  return fears;\n}\n\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\nconst insecurities = extractInsecurities(userInput);\nconst fears = extractFears(userInput) || (data.fears ? [data.fears] : []);\n\n// Topic detection with deeper analysis\nlet topic = data.topic;\nif (!topic) {\n  if (userInput.match(/\\b(business|work|job|career|company)\\b/i)) topic = 'business';\n  else if (userInput.match(/\\b(relationship|partner|spouse|marriage|dating)\\b/i)) topic = 'relationships';\n  else if (userInput.match(/\\b(money|financial|income|debt|bills)\\b/i)) topic = 'finances';\n  else if (userInput.match(/\\b(health|sick|pain|medical|doctor)\\b/i)) topic = 'health';\n  else if (userInput.match(/\\b(family|parents|kids|children)\\b/i)) topic = 'family';\n  else topic = 'general';\n}\n\n// Confidence based on depth of emotional expression\nlet confidence = data.confidence_level || 0.5;\nif (emotions.length > 3 && (fears.length > 0 || insecurities.length > 0)) confidence = 0.95;\nelse if (emotions.length > 2) confidence = 0.85;\nelse if (emotions.length > 0) confidence = 0.75;\n\nreturn {\n  user_input: data.user_input || null,\n  fears: fears.join(', ') || data.fears || null,\n  emotions: emotions.join(', ') || data.emotions || null,\n  topic: topic,\n  insecurities: insecurities.join(', ') || data.insecurities || null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1920
      ],
      "id": "5f28a4db-f3c8-4df1-abec-a9af1da10335",
      "name": "Prepare Emotions"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction parseBoolean(val) {\n  if (val === true || val === 'true' || val === 1) return true;\n  if (val === false || val === 'false' || val === 0) return false;\n  return null;\n}\n\nfunction calculateHappinessImpact(emotions, text) {\n  let impact = 5; // baseline\n  \n  // Positive modifiers\n  if (emotions.includes('happy') || emotions.includes('proud')) impact += 3;\n  if (text.match(/\\b(great|wonderful|amazing|quality time)\\b/i)) impact += 2;\n  if (text.match(/\\b(connected|bonding|together)\\b/i)) impact += 1;\n  \n  // Negative modifiers\n  if (emotions.includes('guilty')) impact -= 3;\n  if (emotions.includes('sad') || emotions.includes('frustrated')) impact -= 2;\n  if (text.match(/\\b(missed|skipped|absent|couldn't)\\b/i)) impact -= 2;\n  if (text.match(/\\b(argument|fight|conflict|tension)\\b/i)) impact -= 3;\n  if (text.match(/\\b(again|always|keeps happening)\\b/i)) impact -= 1;\n  \n  return Math.max(1, Math.min(10, impact));\n}\n\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Extract interaction details\nlet interactionType = data.interaction_type;\nif (!interactionType) {\n  if (userInput.match(/\\bdinner\\b/i)) interactionType = 'dinner';\n  else if (userInput.match(/\\bbreakfast\\b/i)) interactionType = 'breakfast';\n  else if (userInput.match(/\\blunch\\b/i)) interactionType = 'lunch';\n  else if (userInput.match(/\\b(movie|watch|tv)\\b/i)) interactionType = 'watching together';\n  else if (userInput.match(/\\b(game|play|playing)\\b/i)) interactionType = 'play time';\n  else if (userInput.match(/\\b(call|phone|facetime)\\b/i)) interactionType = 'phone call';\n  else if (userInput.match(/\\b(walk|park|outside)\\b/i)) interactionType = 'outdoor activity';\n  else interactionType = 'quality time';\n}\n\n// Extract relationship affected\nlet relationshipAffected = data.relationship_affected;\nif (!relationshipAffected) {\n  if (userInput.match(/\\b(wife|husband|spouse|partner)\\b/i)) relationshipAffected = 'spouse';\n  else if (userInput.match(/\\b(kid|kids|child|children|son|daughter)\\b/i)) relationshipAffected = 'children';\n  else if (userInput.match(/\\b(mom|mother|dad|father|parent)\\b/i)) relationshipAffected = 'parents';\n  else if (userInput.match(/\\b(family)\\b/i)) relationshipAffected = 'family';\n}\n\n// Duration extraction\nlet duration = parseInt(data.duration_minutes);\nif (!duration) {\n  const durationMatch = userInput.match(/(\\d+)\\s*(hours?|hrs?|minutes?|mins?)/i);\n  if (durationMatch) {\n    const value = parseInt(durationMatch[1]);\n    const unit = durationMatch[2].toLowerCase();\n    duration = unit.includes('hour') ? value * 60 : value;\n  }\n}\n\n// Present vs distracted scale (1-10)\nlet presentScore = parseInt(data.present_vs_distracted);\nif (!presentScore) {\n  if (userInput.match(/\\b(present|engaged|focused|attentive)\\b/i)) presentScore = 8;\n  else if (userInput.match(/\\b(distracted|phone|work|busy)\\b/i)) presentScore = 3;\n  else if (userInput.match(/\\b(half|somewhat|partly)\\b/i)) presentScore = 5;\n}\n\n// Work interrupted\nlet workInterrupted = parseBoolean(data.work_interrupted);\nif (workInterrupted === null) {\n  workInterrupted = userInput.match(/\\b(work|job|business|email|call)\\b/i) && \n                   userInput.match(/\\b(during|interrupted|while)\\b/i) ? true : false;\n}\n\n// Guilt level\nlet guiltLevel = parseInt(data.guilt_level);\nif (!guiltLevel && emotions.includes('guilty')) {\n  if (userInput.match(/\\b(so guilty|very guilty|extremely)\\b/i)) guiltLevel = 8;\n  else if (userInput.match(/\\b(guilty)\\b/i)) guiltLevel = 6;\n  else if (userInput.match(/\\b(bad|terrible)\\b/i)) guiltLevel = 7;\n}\n\n// Happiness impact\nconst happinessImpact = parseInt(data.happiness_impact) || calculateHappinessImpact(emotions, userInput);\n\n// Planned vs spontaneous\nlet plannedVsSpontaneous = data.planned_vs_spontaneous;\nif (!plannedVsSpontaneous) {\n  if (userInput.match(/\\b(planned|scheduled|arranged)\\b/i)) plannedVsSpontaneous = 'planned';\n  else plannedVsSpontaneous = 'spontaneous';\n}\n\n// Confidence\nlet confidence = data.confidence_level || 0.5;\nif (interactionType && relationshipAffected && (guiltLevel || happinessImpact)) confidence = 0.9;\nelse if (interactionType && relationshipAffected) confidence = 0.8;\n\nreturn {\n  user_input: data.user_input || null,\n  interaction_type: interactionType,\n  duration_minutes: duration,\n  present_vs_distracted: presentScore,\n  relationship_affected: relationshipAffected,\n  work_interrupted: workInterrupted,\n  guilt_level: guiltLevel,\n  happiness_impact: happinessImpact,\n  planned_vs_spontaneous: plannedVsSpontaneous,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1720
      ],
      "id": "203813e7-61f4-42ab-a3ba-937c4007dd9b",
      "name": "Prepare Family"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction parseMoneyValue(val) {\n  if (!val) return null;\n  if (typeof val === 'number') return val;\n  const cleaned = val.toString().replace(/[$,]/g, '');\n  if (cleaned.toLowerCase().includes('k')) {\n    return parseFloat(cleaned.replace(/k/i, '')) * 1000;\n  }\n  if (cleaned.toLowerCase().includes('m')) {\n    return parseFloat(cleaned.replace(/m/i, '')) * 1000000;\n  }\n  return parseFloat(cleaned) || null;\n}\n\nfunction parseBoolean(val) {\n  if (val === true || val === 'true' || val === 1) return true;\n  if (val === false || val === 'false' || val === 0) return false;\n  return null;\n}\n\nfunction extractTimeSaved(text) {\n  const patterns = [\n    /saving\\s*(?:me\\s*)?(\\d+)\\s*(hours?|hrs?)\\s*(?:per|a|each)?\\s*(week|day|month)/i,\n    /save\\s*(\\d+)\\s*(hours?|hrs?)\\s*(?:per|a|each)?\\s*(week|day|month)/i,\n    /(\\d+)\\s*(hours?|hrs?)\\s*(?:per|a|each)?\\s*(week|day|month)\\s*saved/i,\n    /freed?\\s*up\\s*(\\d+)\\s*(hours?|hrs?)/i\n  ];\n  \n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let hours = parseInt(match[1]);\n      const period = match[3]?.toLowerCase();\n      \n      // Normalize to hours per week\n      if (period === 'day') hours *= 7;\n      else if (period === 'month') hours /= 4;\n      \n      return hours;\n    }\n  }\n  return null;\n}\n\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Extract leverage type\nlet leverageType = data.leverage_type;\nif (!leverageType) {\n  if (userInput.match(/\\b(automat|tool|software|app|system|bot|ai)\\b/i)) {\n    leverageType = 'automation';\n  } else if (userInput.match(/\\b(hire|hired|employee|assistant|va|team|staff)\\b/i)) {\n    leverageType = 'hiring';\n  } else if (userInput.match(/\\b(delegate|delegated|outsource|assign)\\b/i)) {\n    leverageType = 'delegation';\n  } else if (userInput.match(/\\b(process|procedure|framework|template|checklist)\\b/i)) {\n    leverageType = 'systems';\n  } else if (userInput.match(/\\b(invest|investment|money)\\b/i)) {\n    leverageType = 'capital';\n  }\n}\n\n// Extract time saved - MUST CATCH \"10 hours per week\"\nconst timeSaved = extractTimeSaved(userInput) || parseFloat(data.time_saved_hours);\n\n// Extract cost invested\nlet costInvested = parseMoneyValue(data.cost_invested);\nif (!costInvested) {\n  const costPatterns = [\n    /(?:cost|spent|invested|paid)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /\\$(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:cost|investment|spent)/i\n  ];\n  \n  for (const pattern of costPatterns) {\n    const match = userInput.match(pattern);\n    if (match) {\n      costInvested = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n}\n\n// Extract revenue impact\nlet revenueImpact = parseMoneyValue(data.revenue_impact);\nif (!revenueImpact) {\n  const revenuePatterns = [\n    /(?:generated|made|earned|revenue of)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /\\$(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:revenue|income|profit)/i\n  ];\n  \n  for (const pattern of revenuePatterns) {\n    const match = userInput.match(pattern);\n    if (match) {\n      revenueImpact = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n}\n\n// Implementation difficulty (1-10)\nlet difficulty = parseInt(data.implementation_difficulty);\nif (!difficulty) {\n  if (userInput.match(/\\b(easy|simple|quick|straightforward)\\b/i)) difficulty = 3;\n  else if (userInput.match(/\\b(hard|difficult|complex|challenging)\\b/i)) difficulty = 8;\n  else if (userInput.match(/\\b(moderate|medium|okay)\\b/i)) difficulty = 5;\n}\n\n// Still using\nlet stillUsing = parseBoolean(data.still_using);\nif (stillUsing === null) {\n  if (userInput.match(/\\b(still using|continue|continuing|kept)\\b/i)) stillUsing = true;\n  else if (userInput.match(/\\b(stopped|quit|abandoned|gave up)\\b/i)) stillUsing = false;\n  else if (userInput.match(/\\b(just|new|started|beginning)\\b/i)) stillUsing = true;\n}\n\n// Failure reason\nlet failureReason = data.failure_reason;\nif (!failureReason && stillUsing === false) {\n  if (userInput.match(/\\b(expensive|cost too much)\\b/i)) failureReason = 'too expensive';\n  else if (userInput.match(/\\b(complicated|complex|hard to use)\\b/i)) failureReason = 'too complex';\n  else if (userInput.match(/\\b(didn't work|ineffective|useless)\\b/i)) failureReason = 'ineffective';\n  else if (userInput.match(/\\b(better option|switched|replaced)\\b/i)) failureReason = 'found better solution';\n}\n\n// Multiplier effect\nlet multiplierEffect = parseFloat(data.multiplier_effect);\nif (!multiplierEffect && timeSaved && costInvested) {\n  // Calculate rough ROI multiplier\n  const weeklyValue = timeSaved * 50; // Assume $50/hour value\n  const monthlyValue = weeklyValue * 4;\n  multiplierEffect = monthlyValue / costInvested;\n}\n\n// Confidence\nlet confidence = data.confidence_level || 0.5;\nif (leverageType && timeSaved) confidence = 0.9;\nelse if (leverageType || timeSaved) confidence = 0.7;\n\nreturn {\n  user_input: data.user_input || null,\n  leverage_type: leverageType,\n  time_saved_hours: timeSaved,\n  cost_invested: costInvested,\n  revenue_impact: revenueImpact,\n  implementation_difficulty: difficulty,\n  still_using: stillUsing,\n  failure_reason: failureReason,\n  multiplier_effect: multiplierEffect,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1520
      ],
      "id": "14c2b2a3-a771-4fb7-94cc-7a795d7c6b5c",
      "name": "Prepare Leverage"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Enhanced pattern detection\nlet pattern = data.Pattern;\nif (!pattern) {\n  if (userInput.match(/\\b(always|every time|keeps happening|again and again)\\b/i)) {\n    pattern = 'recurring';\n  } else if (userInput.match(/\\b(same|repeat|cycle|loop)\\b/i)) {\n    pattern = 'repeating';\n  } else if (userInput.match(/\\b(stuck|blocked|can't move)\\b/i)) {\n    pattern = 'stagnation';\n  } else if (userInput.match(/\\b(procrastinat|delay|put off|avoid)\\b/i)) {\n    pattern = 'procrastination';\n  } else if (userInput.match(/\\b(never|can't ever|impossible)\\b/i)) {\n    pattern = 'persistent block';\n  } else if (userInput.match(/\\b(worse|deteriorating|declining)\\b/i)) {\n    pattern = 'downward spiral';\n  } else {\n    pattern = 'behavioral';\n  }\n}\n\n// Enhanced category detection\nlet category = data.Category;\nif (!category) {\n  if (userInput.match(/\\b(client|customer|sales|deal|revenue)\\b/i)) {\n    category = 'business:sales';\n  } else if (userInput.match(/\\b(sleep|health|stress|tired)\\b/i)) {\n    category = 'health';\n  } else if (userInput.match(/\\b(family|relationship|spouse|kids)\\b/i)) {\n    category = 'family';\n  } else if (userInput.match(/\\b(workout|gym|exercise|fitness)\\b/i)) {\n    category = 'fitness';\n  } else if (userInput.match(/\\b(routine|habit|morning|evening)\\b/i)) {\n    category = 'routine';\n  } else if (userInput.match(/\\b(goal|target|achieve)\\b/i)) {\n    category = 'goals';\n  } else {\n    category = 'general';\n  }\n}\n\n// Confidence based on pattern clarity\nlet confidence = data.confidence_level || 0.5;\nif (pattern !== 'behavioral' && category !== 'general') confidence = 0.9;\nelse if (pattern !== 'behavioral' || category !== 'general') confidence = 0.7;\n\nreturn {\n  user_input: data.user_input || null,\n  CommonProblems: data.CommonProblems || data.user_input || null,\n  Pattern: pattern,\n  Category: category,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -920
      ],
      "id": "175da216-e564-4e0f-87a2-e70acab49948",
      "name": "Prepare Common Problems"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nfunction extractPerformanceData(text) {\n  const performance = {\n    whatWentWell: [],\n    whatBlocked: [],\n    tomorrowHurdle: []\n  };\n  \n  // Split by sentences or key phrases\n  const sentences = text.split(/[.!?]|(?:obstacles?:|wins?:|tomorrow)/i);\n  \n  for (const sentence of sentences) {\n    const s = sentence.trim().toLowerCase();\n    \n    // Success indicators\n    if (s.match(/\\b(finished|completed|done|achieved|accomplished|hit|reached|closed|sold|made)\\b/)) {\n      performance.whatWentWell.push(sentence.trim());\n    }\n    \n    // Blockers\n    if (s.match(/\\b(blocked|stuck|failed|couldn't|didn't|missed|struggled)\\b/)) {\n      performance.whatBlocked.push(sentence.trim());\n    }\n    \n    // Tomorrow mentions\n    if (s.match(/\\b(tomorrow|next|upcoming|scheduled)\\b/)) {\n      performance.tomorrowHurdle.push(sentence.trim());\n    }\n  }\n  \n  // Extract specific achievements\n  if (text.match(/\\b(closed|sold)\\s*(\\d+)?\\s*(deals?|clients?|sales?)/i)) {\n    const match = text.match(/\\b(closed|sold)\\s*(\\d+)?\\s*(deals?|clients?|sales?)/i);\n    performance.whatWentWell.push(`${match[0]}`);\n  }\n  \n  if (text.match(/\\$[\\d,]+|earned|made.*\\d+/)) {\n    const match = text.match(/(\\$[\\d,]+|earned.*?\\d+|made.*?\\d+)/);\n    if (match) performance.whatWentWell.push(match[0]);\n  }\n  \n  return performance;\n}\n\nconst userInput = data.WhatWentWell || data.TomorrowHurdle || data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\nconst performanceData = extractPerformanceData(userInput);\n\n// Smart extraction from combined input\nlet whatWentWell = data.WhatWentWell;\nlet whatBlocked = data.WhatBlocked;\nlet tomorrowHurdle = data.TomorrowHurdle;\n\n// If router passed entire text to multiple fields, extract properly\nif (whatWentWell && whatWentWell.includes('Obstacles:')) {\n  const parts = whatWentWell.split(/obstacles?:/i);\n  whatWentWell = parts[0].replace(/today's wins?:/i, '').trim();\n  \n  if (parts[1]) {\n    const obstacleParts = parts[1].split(/tomorrow|ready to tackle/i);\n    whatBlocked = obstacleParts[0].trim() || null;\n    if (whatBlocked === 'none!') whatBlocked = null;\n  }\n}\n\nif (tomorrowHurdle && tomorrowHurdle.includes('Ready to tackle')) {\n  const match = tomorrowHurdle.match(/ready to tackle\\s*(.+)/i);\n  if (match) {\n    tomorrowHurdle = match[1].trim();\n  }\n}\n\n// Use extracted data if not already set\nif (!whatWentWell && performanceData.whatWentWell.length > 0) {\n  whatWentWell = performanceData.whatWentWell.join('; ');\n}\nif (!whatBlocked && performanceData.whatBlocked.length > 0) {\n  whatBlocked = performanceData.whatBlocked.join('; ');\n}\nif (!tomorrowHurdle && performanceData.tomorrowHurdle.length > 0) {\n  tomorrowHurdle = performanceData.tomorrowHurdle.join('; ');\n}\n\n// Calculate reflection due date if tomorrow mentioned\nlet reflectionDueAt = null;\nconst dateTime = extractDateTime(userInput);\nif (dateTime.date || userInput.match(/tomorrow/i)) {\n  const tomorrow = new Date();\n  tomorrow.setDate(tomorrow.getDate() + 1);\n  if (dateTime.time) {\n    reflectionDueAt = `${tomorrow.toISOString().split('T')[0]}T${dateTime.time}`;\n  } else {\n    reflectionDueAt = tomorrow.toISOString();\n  }\n}\n\n// Confidence\nlet confidence = data.confidence_level || 0.5;\nif ((whatWentWell || whatBlocked) && tomorrowHurdle) confidence = 0.9;\nelse if (whatWentWell || whatBlocked || tomorrowHurdle) confidence = 0.7;\n\nreturn {\n  user_input: data.user_input || userInput || null,\n  WhatWentWell: whatWentWell,\n  WhatBlocked: whatBlocked,\n  TomorrowHurdle: tomorrowHurdle,\n  reflectionDueAt: reflectionDueAt,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -520
      ],
      "id": "f1e2c65a-f881-4e04-8936-aadff18667c3",
      "name": "Prepare Performance"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\nfunction parseMoneyValue(val) {\n  if (!val) return null;\n  if (typeof val === 'number') return val;\n  const cleaned = val.toString().replace(/[$,]/g, '');\n  if (cleaned.toLowerCase().includes('k')) {\n    return parseFloat(cleaned.replace(/k/i, '')) * 1000;\n  }\n  if (cleaned.toLowerCase().includes('m')) {\n    return parseFloat(cleaned.replace(/m/i, '')) * 1000000;\n  }\n  return parseFloat(cleaned) || null;\n}\n\nfunction parseBoolean(val) {\n  if (val === true || val === 'true' || val === 1) return true;\n  if (val === false || val === 'false' || val === 0) return false;\n  return null;\n}\n\n// BEAST MODE EXTRACTION FUNCTIONS\nfunction extractContactName(text) {\n  // Patterns for names after key phrases\n  const patterns = [\n    /(?:with|met|meeting|call with|talked to|spoke with|connected with|reached out to|heard from|introduced to)\\s+([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)/gi,\n    /([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?)\\s+(?:introduced|referred|connected|reached out)/gi,\n    /(?:from|at|with)\\s+([A-Z][a-z]+)\\s+(?:from|at|@|of)\\s+([A-Z][A-Za-z0-9\\s&]+)/gi\n  ];\n  \n  for (const pattern of patterns) {\n    const matches = [...text.matchAll(pattern)];\n    if (matches.length > 0) {\n      // Return the first captured name\n      return matches[0][1].trim();\n    }\n  }\n  return null;\n}\n\nfunction extractCompanyName(text) {\n  const patterns = [\n    /(?:from|at|with|@|of)\\s+([A-Z][A-Za-z0-9\\s&]+?)\\s*(?:Corp|Inc|LLC|Ltd|Company|Co\\.?|Group|Partners|Agency|Studio|Labs|Tech|Digital|Consulting|Services|Solutions)/gi,\n    /(?:from|at|with)\\s+[A-Z][a-z]+\\s+(?:from|at|of)\\s+([A-Z][A-Za-z0-9\\s&]+)/gi,\n    /(?:joined|joining)\\s+([A-Z][A-Za-z0-9\\s&]+)/gi\n  ];\n  \n  for (const pattern of patterns) {\n    const matches = [...text.matchAll(pattern)];\n    if (matches.length > 0) {\n      const company = matches[0][matches[0].length - 1].trim();\n      // Clean up common suffixes\n      return company.replace(/\\s*(Corp\\.?|Inc\\.?|LLC|Ltd\\.?)$/, '').trim();\n    }\n  }\n  return null;\n}\n\nfunction extractReferralCount(text) {\n  const patterns = [\n    /referring\\s+(?:me\\s+)?(?:to\\s+)?(\\d+)\\s*(?:potential\\s*)?(?:clients?|leads?|contacts?|people|prospects?)/i,\n    /(\\d+)\\s*(?:referrals?|introductions?|connections?)/i,\n    /(?:gave|provided|sent|made)\\s*(?:me\\s*)?(\\d+)\\s*(?:referrals?|introductions?|connections?)/i,\n    /connected\\s+(?:me\\s+)?(?:with\\s+)?(\\d+)/i\n  ];\n  \n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match) return parseInt(match[1]);\n  }\n  return null;\n}\n\nfunction extractFollowUpInfo(text) {\n  const followUpPhrases = [\n    'follow up', 'following up', 'will call', 'will email', 'scheduled',\n    'meeting set', 'call scheduled', 'booked', 'calendar', 'next week',\n    'next month', 'tomorrow', 'will connect', 'touch base'\n  ];\n  \n  return followUpPhrases.some(phrase => text.toLowerCase().includes(phrase));\n}\n\nfunction extractRelationshipStrength(text, emotions) {\n  // 1-10 scale based on context clues\n  let strength = 5; // baseline\n  \n  // Positive indicators\n  if (text.match(/great|excellent|amazing|fantastic|wonderful/i)) strength += 2;\n  if (text.match(/referring|referral|introduced|connecting/i)) strength += 2;\n  if (text.match(/long.?time|years|established|strong/i)) strength += 1;\n  if (text.match(/trusted|reliable|go.?to|best/i)) strength += 1;\n  if (emotions.includes('happy') || emotions.includes('excited')) strength += 1;\n  \n  // Negative indicators\n  if (text.match(/new|first|initial|just met/i)) strength -= 2;\n  if (text.match(/cold|unsure|maybe|might/i)) strength -= 1;\n  if (emotions.includes('anxious') || emotions.includes('uncertain')) strength -= 1;\n  \n  return Math.max(1, Math.min(10, strength));\n}\n\nfunction extractValueExchange(text) {\n  const valueGiven = [];\n  const valueReceived = [];\n  \n  // What was provided\n  if (text.match(/(?:i|we)\\s+(?:gave|provided|shared|offered|helped with|showed)/i)) {\n    if (text.match(/advice|tips|guidance|insights?|feedback/i)) valueGiven.push('advice');\n    if (text.match(/introduction|connection|referral/i)) valueGiven.push('connections');\n    if (text.match(/resource|tool|template|document/i)) valueGiven.push('resources');\n    if (text.match(/demo|presentation|pitch/i)) valueGiven.push('demo');\n  }\n  \n  // What was received\n  if (text.match(/(?:they|he|she)\\s+(?:gave|provided|shared|offered|referring|introduced)/i)) {\n    if (text.match(/referr|introduc|connect/i)) valueReceived.push('referrals');\n    if (text.match(/advice|tips|guidance|insights?|feedback/i)) valueReceived.push('advice');\n    if (text.match(/business|client|lead|opportunity/i)) valueReceived.push('opportunities');\n  }\n  \n  return {\n    given: valueGiven.length > 0 ? valueGiven.join(', ') : null,\n    received: valueReceived.length > 0 ? valueReceived.join(', ') : null\n  };\n}\n\nfunction extractContactMethod(text) {\n  // More specific than just contact_type\n  const methods = {\n    'zoom call': ['zoom', 'zoom call', 'zoom meeting'],\n    'video call': ['video call', 'video chat', 'teams', 'google meet', 'skype'],\n    'phone call': ['phone', 'called', 'rang', 'phone call'],\n    'in-person': ['coffee', 'lunch', 'dinner', 'met up', 'in person', 'face to face', 'f2f'],\n    'email': ['emailed', 'sent email', 'email exchange'],\n    'linkedin': ['linkedin', 'connected on linkedin', 'li message'],\n    'conference': ['conference', 'event', 'summit', 'meetup', 'networking event']\n  };\n  \n  const textLower = text.toLowerCase();\n  for (const [type, keywords] of Object.entries(methods)) {\n    if (keywords.some(keyword => textLower.includes(keyword))) {\n      return type;\n    }\n  }\n  return data.contact_type || 'general';\n}\n\n// Extract everything from user input\nconst userInput = data.user_input || '';\nconst contactName = extractContactName(userInput);\nconst companyName = extractCompanyName(userInput);\nconst referralCount = extractReferralCount(userInput);\nconst followUpScheduled = extractFollowUpInfo(userInput);\nconst relationshipStrength = extractRelationshipStrength(userInput, data.emotional_signals || []);\nconst valueExchange = extractValueExchange(userInput);\nconst contactMethod = extractContactMethod(userInput);\n\n// Extract revenue if mentioned\nlet revenueAttributed = null;\nconst revenueMatch = userInput.match(/(?:worth|valued at|potential of|could be|revenue of)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i);\nif (revenueMatch) {\n  revenueAttributed = parseMoneyValue(revenueMatch[1]);\n}\n\n// Determine last interaction date (today unless specified)\nlet lastInteractionDate = new Date().toISOString().split('T')[0]; // Today\nif (userInput.match(/yesterday/i)) {\n  const yesterday = new Date();\n  yesterday.setDate(yesterday.getDate() - 1);\n  lastInteractionDate = yesterday.toISOString().split('T')[0];\n} else if (userInput.match(/last week/i)) {\n  const lastWeek = new Date();\n  lastWeek.setDate(lastWeek.getDate() - 7);\n  lastInteractionDate = lastWeek.toISOString().split('T')[0];\n}\n\n// Build metadata for additional context\nconst metadata = {\n  contact_name: contactName,\n  company_name: companyName,\n  meeting_quality: userInput.match(/great|excellent|fantastic/i) ? 'excellent' : 'good',\n  next_steps: followUpScheduled ? 'follow-up planned' : null\n};\n\n// Confidence based on data completeness\nlet confidence = data.confidence_level || 0.5;\nif (contactName && referralCount) confidence = 0.95;\nelse if (contactName || referralCount) confidence = 0.8;\n\nreturn {\n  user_input: data.user_input || null,\n  contact_type: contactMethod,\n  relationship_strength: relationshipStrength,\n  last_interaction_date: lastInteractionDate,\n  value_provided: valueExchange.given || data.value_provided || null,\n  value_received: valueExchange.received || data.value_received || null,\n  follow_up_scheduled: followUpScheduled || parseBoolean(data.follow_up_scheduled),\n  referrals_generated: referralCount || parseInt(data.referrals_generated) || null,\n  revenue_attributed: revenueAttributed || parseMoneyValue(data.revenue_attributed),\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(data.emotional_signals || []),\n  // Store extracted details in metadata\n  metadata: JSON.stringify(metadata)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -2720
      ],
      "id": "532afbb9-d7d5-4525-8b51-5a021ff6b053",
      "name": "Prepare Business Networking"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\nfunction parseMoneyValue(val) {\n  if (!val) return null;\n  if (typeof val === 'number') return val;\n  const cleaned = val.toString().replace(/[$,]/g, '');\n  if (cleaned.toLowerCase().includes('k')) {\n    return parseFloat(cleaned.replace(/k/i, '')) * 1000;\n  }\n  if (cleaned.toLowerCase().includes('m')) {\n    return parseFloat(cleaned.replace(/m/i, '')) * 1000000;\n  }\n  return parseFloat(cleaned) || null;\n}\n\nfunction extractROAS(text) {\n  const patterns = [\n    /(\\d+(?:\\.\\d+)?)\\s*x\\s*(?:roas|roi|return)/i,\n    /roas\\s*(?:of\\s*)?(\\d+(?:\\.\\d+)?)\\s*x/i,\n    /roi\\s*(?:of\\s*)?(\\d+(?:\\.\\d+)?)\\s*x/i,\n    /(\\d+(?:\\.\\d+)?)\\s*%\\s*(?:roas|roi|return)/i,\n    /roas\\s*(?:of\\s*)?(\\d+(?:\\.\\d+)?)\\s*%/i\n  ];\n  \n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match) {\n      const value = parseFloat(match[1]);\n      // For X format (5.4x), return as is\n      // For percentage format (540%), convert to X format\n      if (text.includes('%') && !text.includes('x')) {\n        return value / 100; // 540% becomes 5.4\n      }\n      return value;\n    }\n  }\n  return null;\n}\n\nconst userInput = data.user_input || '';\n\n// Try to extract actual spend and revenue first\nlet adSpend = parseMoneyValue(data.ad_spend);\nlet revenue = parseMoneyValue(data.revenue_generated);\n\n// Extract from user input\nif (!adSpend && userInput) {\n  const spendPatterns = [\n    /spent\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:ad\\s*)?spend/i,\n    /budget\\s*(?:of\\s*)?\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i\n  ];\n  \n  for (const pattern of spendPatterns) {\n    const match = userInput.match(pattern);\n    if (match) {\n      adSpend = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n}\n\nif (!revenue && userInput) {\n  const revenuePatterns = [\n    /(?:made|generated|earned|revenue\\s*of)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i,\n    /\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)\\s*(?:revenue|sales|return)/i,\n    /(?:brought\\s*in|resulted\\s*in)\\s*\\$?(\\d+(?:,\\d{3})*(?:\\.\\d+)?k?m?)/i\n  ];\n  \n  for (const pattern of revenuePatterns) {\n    const match = userInput.match(pattern);\n    if (match) {\n      revenue = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n}\n\n// Extract ROAS - this is the key value we want to store\nconst roasValue = extractROAS(userInput);\n\n// Extract other metrics\nlet impressions = data.impressions;\nlet clicks = data.clicks;\nlet conversions = data.conversions;\n\nconst metricsPatterns = {\n  impressions: /(\\d+(?:,\\d{3})*)\\s*impressions?/i,\n  clicks: /(\\d+(?:,\\d{3})*)\\s*clicks?/i,\n  conversions: /(\\d+(?:,\\d{3})*)\\s*conversions?/i\n};\n\nfor (const [metric, pattern] of Object.entries(metricsPatterns)) {\n  const match = userInput.match(pattern);\n  if (match) {\n    const value = parseInt(match[1].replace(/,/g, ''));\n    if (metric === 'impressions') impressions = value;\n    else if (metric === 'clicks') clicks = value;\n    else if (metric === 'conversions') conversions = value;\n  }\n}\n\n// Set confidence level\nlet confidenceLevel = data.confidence_level || 0.5;\nif (roasValue || adSpend || revenue) {\n  confidenceLevel = 0.9;\n}\n\nreturn {\n  user_input: data.user_input || null,\n  ad_spend: adSpend || null,\n  revenue_generated: revenue || null,\n  platform: data.platform || null,\n  campaign_type: data.campaign_type || null,\n  impressions: impressions ? parseInt(impressions) : null,\n  clicks: clicks ? parseInt(clicks) : null,\n  conversions: conversions ? parseInt(conversions) : null,\n  roas_reported: roasValue || null,  // NEW FIELD - stores the ROAS value directly\n  hours_spent_optimizing: data.hours_spent_optimizing ? parseFloat(data.hours_spent_optimizing) : null,\n  confidence_level: confidenceLevel,\n  emotional_signals: JSON.stringify(data.emotional_signals || [])\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -2520
      ],
      "id": "ae6ea453-3484-4a1f-b99c-e07070e0ecb5",
      "name": "Prepare Business Advertisments"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c2",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "recent_interactions",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "recent_interactions"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c4",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:sales",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_sales"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c5",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:networking",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_networking"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c6",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:advertisments",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_advertisments"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c7",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "fitness",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "fitness"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c8",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "health",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "health"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c9",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "emotions",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "emotions"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c10",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "family",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "family"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c11",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "leverage",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "leverage"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c12",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "goals",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "goals"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c13",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "routine",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "routine"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c14",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "common_problems",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "common_problems"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c15",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "user_feedback",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "user_feedback"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "c16",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "performance",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "performance"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "7ec4cab1-1b62-4fea-b50e-9adec4edff9b",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:finance",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_finance"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "899dfbeb-a65b-455e-8809-e18193c49610",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:product",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_product"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "8b403bb2-3be2-4a0d-b53b-003a85fcabda",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:operations",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_operations"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "f2be194b-973b-40df-b3bd-30e87443c14e",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:agency",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_agency"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "27a53e44-c17b-45a6-96f2-e7ab1bd4ecb9",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:content",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_content"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "78c91657-40c3-4112-8c2d-6ea05d7d03dc",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:saas",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_saas"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "1c0eaad3-eea3-4b6b-a503-1a82b88d60a5",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:models",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_models"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "8004d761-225e-4fd4-aee4-1e3ba0eab7dd",
                    "leftValue": "={{ $json.table }}",
                    "rightValue": "business:ecommerce",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "business_ecommerce"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "730cd425-b209-45ea-a2ee-593fb19cfbbc",
                    "leftValue": "{{ $json.table }}",
                    "rightValue": "unknown",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "unknown"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        860,
        -940
      ],
      "id": "3eb26b22-5ab3-4b64-a518-36b41b2dc0d5",
      "name": "Route Tables1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO common_problems (\n  user_id,\n  \"user input\",\n  \"CommonProblems\",\n  \"Pattern\",\n  \"Category\",\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.CommonProblems ? \"'\" + $json.CommonProblems.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.Pattern ? \"'\" + $json.Pattern.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.Category ? \"'\" + $json.Category.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -920
      ],
      "id": "ee4b6e36-3e13-4f34-930d-74834334bdc7",
      "name": "Insert Common Problems1",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO performance (\n  user_id,\n  \"user input\",\n  \"WhatWentWell\",\n  \"WhatBlocked\",\n  \"TomorrowHurdle\",\n  \"reflectionDueAt\",\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.WhatWentWell ? \"'\" + $json.WhatWentWell.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.WhatBlocked ? \"'\" + $json.WhatBlocked.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.TomorrowHurdle ? \"'\" + $json.TomorrowHurdle.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.reflectionDueAt ? \"'\" + $json.reflectionDueAt + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -520
      ],
      "id": "cd1e3322-143e-459d-9997-f3d20b851eff",
      "name": "Insert Performance1",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\nfunction parseMoneyValue(val) {\n  if (!val) return null;\n  if (typeof val === 'number') return val;\n  const cleaned = val.toString().replace(/[$,]/g, '');\n  if (cleaned.toLowerCase().includes('k')) {\n    return parseFloat(cleaned.replace(/k/i, '')) * 1000;\n  }\n  if (cleaned.toLowerCase().includes('m')) {\n    return parseFloat(cleaned.replace(/m/i, '')) * 1000000;\n  }\n  return parseFloat(cleaned) || null;\n}\n\nreturn {\n  user_input: data.user_input || null,\n  deal_value: parseMoneyValue(data.deal_value || data.total_value || data.revenue || data.amount || data.sales),\n  deal_source: data.deal_source || null,\n  sales_channel: data.sales_channel || null,\n  time_to_close: parseInt(data.time_to_close) || null,\n  deal_stage: data.deal_stage || null,\n  rejection_reason: data.rejection_reason || null,\n  energy_level_during_sale: parseInt(data.energy_level_during_sale || data.energy_level) || null,\n  follow_ups_required: parseInt(data.follow_ups_required) || null,\n  recipient: data.recipient || data.contact_name || null,\n  company_of_recipient: data.company_of_recipient || data.company || null,\n  topic: data.topic || null,\n  analysis_sentiment: data.analysis_sentiment || null,\n  analysis_keywords: data.analysis_keywords || null,\n  analysis_objections: data.analysis_objections || null,\n  analysis_next_steps: data.analysis_next_steps || null,\n  analysis_recommendation: data.analysis_recommendation || null,\n  product_service_offered: data.product_service_offered || null,\n  email_sent: data.email_sent || null,\n  confidence_level: data.confidence_level || 0.5,\n  emotional_signals: JSON.stringify(data.emotional_signals || [])\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -2920
      ],
      "id": "57f4d2cc-77e6-4edd-bfd9-88d363475120",
      "name": "Prepare Business Sales"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:sales\" (\n  user_id, \n  \"user input\", \n  deal_value, \n  deal_source, \n  sales_channel,\n  time_to_close, \n  deal_stage, \n  rejection_reason, \n  energy_level_during_sale,\n  follow_ups_required, \n  recipient, \n  company_of_recipient, \n  topic,\n  analysis_sentiment, \n  analysis_keywords, \n  analysis_objections, \n  analysis_next_steps, \n  analysis_recommendation, \n  product_service_offered,\n  email_sent,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.deal_value !== undefined && $json.deal_value !== null ? $json.deal_value : 'NULL' }},\n  {{ $json.deal_source ? \"'\" + $json.deal_source.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.sales_channel ? \"'\" + $json.sales_channel.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.time_to_close !== undefined ? $json.time_to_close : 'NULL' }},\n  {{ $json.deal_stage ? \"'\" + $json.deal_stage.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.rejection_reason ? \"'\" + $json.rejection_reason.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.energy_level_during_sale !== undefined ? $json.energy_level_during_sale : 'NULL' }},\n  {{ $json.follow_ups_required !== undefined ? $json.follow_ups_required : 'NULL' }},\n  {{ $json.recipient ? \"'\" + $json.recipient.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.company_of_recipient ? \"'\" + $json.company_of_recipient.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.topic ? \"'\" + $json.topic.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_sentiment ? \"'\" + $json.analysis_sentiment.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_keywords ? \"'\" + $json.analysis_keywords.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_objections ? \"'\" + $json.analysis_objections.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_next_steps ? \"'\" + $json.analysis_next_steps.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_recommendation ? \"'\" + $json.analysis_recommendation.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.product_service_offered ? \"'\" + $json.product_service_offered.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.email_sent ? \"'\" + $json.email_sent.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -2920
      ],
      "id": "2df1e1e3-a608-456f-ae8a-d834b9ec318b",
      "name": "Insert Business Sales",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:networking\" (\n  user_id, \n  \"user input\", \n  contact_type, \n  relationship_strength,\n  last_interaction_date,\n  value_provided,\n  value_received, \n  follow_up_scheduled, \n  referrals_generated, \n  revenue_attributed,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.contact_type ? \"'\" + $json.contact_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.relationship_strength !== undefined ? $json.relationship_strength : 'NULL' }},\n  {{ $json.last_interaction_date ? \"'\" + $json.last_interaction_date + \"'\" : 'NULL' }},\n  {{ $json.value_provided ? \"'\" + $json.value_provided.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.value_received ? \"'\" + $json.value_received.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.follow_up_scheduled !== undefined && $json.follow_up_scheduled !== null ? $json.follow_up_scheduled : 'NULL' }},\n  {{ $json.referrals_generated !== undefined ? $json.referrals_generated : 'NULL' }},\n  {{ $json.revenue_attributed !== undefined ? $json.revenue_attributed : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals || \"[]\" }}'\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -2720
      ],
      "id": "aec84f44-6ab4-459c-a23d-4e955a3caa85",
      "name": "Insert Business Networking",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO fitness (\n  user_id, \n  user_input, \n  \"Activity\", \n  \"Time/weight\", \n  \"MetricType\",\n  current_value, \n  workout_type, \n  duration_minutes, \n  intensity,\n  energy_before, \n  energy_after, \n  workout_time, \n  missed_planned_workout,\n  excuse_if_missed, \n  productivity_score_after,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.Activity ? \"'\" + $json.Activity.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json['Time/weight'] !== undefined && $json['Time/weight'] !== null ? $json['Time/weight'] : 'NULL' }},\n  {{ $json.MetricType ? \"'\" + $json.MetricType.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.current_value ? \"'\" + $json.current_value.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.workout_type ? \"'\" + $json.workout_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.duration_minutes !== undefined && $json.duration_minutes !== null ? $json.duration_minutes : 'NULL' }},\n  {{ $json.intensity !== undefined && $json.intensity !== null ? $json.intensity : 'NULL' }},\n  {{ $json.energy_before !== undefined && $json.energy_before !== null ? $json.energy_before : 'NULL' }},\n  {{ $json.energy_after !== undefined && $json.energy_after !== null ? $json.energy_after : 'NULL' }},\n  {{ $json.workout_time ? \"'\" + $json.workout_time.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.missed_planned_workout !== undefined && $json.missed_planned_workout !== null ? $json.missed_planned_workout : 'NULL' }},\n  {{ $json.excuse_if_missed ? \"'\" + $json.excuse_if_missed.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.productivity_score_after !== undefined && $json.productivity_score_after !== null ? $json.productivity_score_after : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -2320
      ],
      "id": "f7a37608-4fc3-4c6c-bcba-ccfe8c1c8912",
      "name": "Insert Fitness",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:advertisments\" (\n  user_id, \n  \"user input\", \n  ad_spend, \n  revenue_generated, \n  platform,\n  campaign_type, \n  impressions, \n  clicks, \n  conversions,\n  roas_reported,\n  hours_spent_optimizing,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.ad_spend !== undefined && $json.ad_spend !== null ? $json.ad_spend : 'NULL' }},\n  {{ $json.revenue_generated !== undefined && $json.revenue_generated !== null ? $json.revenue_generated : 'NULL' }},\n  {{ $json.platform ? \"'\" + $json.platform.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.campaign_type ? \"'\" + $json.campaign_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.impressions !== undefined && $json.impressions !== null ? $json.impressions : 'NULL' }},\n  {{ $json.clicks !== undefined && $json.clicks !== null ? $json.clicks : 'NULL' }},\n  {{ $json.conversions !== undefined && $json.conversions !== null ? $json.conversions : 'NULL' }},\n  {{ $json.roas_reported !== undefined && $json.roas_reported !== null ? $json.roas_reported : 'NULL' }},\n  {{ $json.hours_spent_optimizing !== undefined && $json.hours_spent_optimizing !== null ? $json.hours_spent_optimizing : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals || \"[]\" }}'\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -2520
      ],
      "id": "fb6d7900-54ef-4403-88da-18e3f68d7b52",
      "name": "Insert Business Advertisments",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n\nconst data = $json.data;\n\n// Include all helper functions above\n\nfunction extractFitnessData(text) {\n  const fitness = {\n    activity: null,\n    distance: null,\n    duration: null,\n    intensity: null,\n    time_of_day: null,\n    energy_before: null,\n    energy_after: null,\n    workout_time: null\n  };\n  \n  // Activity detection with variations\n  const activityPatterns = {\n    running: /\\b(ran|run|running|jog|jogging|sprint|sprinted)\\b/i,\n    walking: /\\b(walk|walked|walking|stroll|hiking|hiked)\\b/i,\n    cycling: /\\b(bike|biked|cycling|cycle|rode|riding)\\b/i,\n    swimming: /\\b(swim|swam|swimming|laps)\\b/i,\n    gym: /\\b(gym|workout|lifted|lifting|weights|strength)\\b/i,\n    yoga: /\\b(yoga|stretch|stretched|flexibility)\\b/i,\n    cardio: /\\b(cardio|hiit|circuit|crossfit)\\b/i\n  };\n  \n  for (const [activity, pattern] of Object.entries(activityPatterns)) {\n    if (pattern.test(text)) {\n      fitness.activity = activity;\n      break;\n    }\n  }\n  \n  // Distance extraction with units\n  const distancePatterns = [\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*(miles?|mi\\.?)/i, unit: 'miles' },\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*(kilometers?|km)/i, unit: 'km' },\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*(meters?|m)\\b/i, unit: 'meters' },\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*k\\b/i, unit: 'km' }\n  ];\n  \n  for (const pattern of distancePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      fitness.distance = parseFloat(match[1]);\n      fitness.distance_unit = pattern.unit;\n      break;\n    }\n  }\n  \n  // Duration extraction\n  const durationMatch = text.match(/(\\d+)\\s*(hours?|hrs?|minutes?|mins?)/i);\n  if (durationMatch) {\n    const value = parseInt(durationMatch[1]);\n    const unit = durationMatch[2].toLowerCase();\n    fitness.duration = unit.includes('hour') ? value * 60 : value;\n  }\n  \n  // Time of day extraction\n  const timeOfDayPatterns = {\n    morning: /\\b(morning|dawn|sunrise|am|5\\s*am|6\\s*am|7\\s*am|8\\s*am)\\b/i,\n    afternoon: /\\b(afternoon|lunch|noon|midday|pm)\\b/i,\n    evening: /\\b(evening|dusk|sunset|night|6\\s*pm|7\\s*pm|8\\s*pm)\\b/i\n  };\n  \n  for (const [timeOfDay, pattern] of Object.entries(timeOfDayPatterns)) {\n    if (pattern.test(text)) {\n      fitness.time_of_day = timeOfDay;\n      break;\n    }\n  }\n  \n  // Energy level detection\n  const energyPatterns = {\n    high: /\\b(energized|pumped|great|amazing|fantastic|ready)\\b/i,\n    medium: /\\b(okay|fine|decent|alright)\\b/i,\n    low: /\\b(tired|exhausted|drained|sluggish|slow)\\b/i\n  };\n  \n  for (const [level, pattern] of Object.entries(energyPatterns)) {\n    if (pattern.test(text)) {\n      fitness.energy_after = level === 'high' ? 8 : level === 'medium' ? 5 : 3;\n      break;\n    }\n  }\n  \n  // Intensity detection\n  if (text.match(/\\b(intense|hard|tough|brutal|killer)\\b/i)) fitness.intensity = 8;\n  else if (text.match(/\\b(moderate|decent|good)\\b/i)) fitness.intensity = 5;\n  else if (text.match(/\\b(easy|light|gentle|slow)\\b/i)) fitness.intensity = 3;\n  \n  // Extract actual workout time\n  const dateTime = extractDateTime(text);\n  if (dateTime.time) fitness.workout_time = dateTime.time;\n  \n  return fitness;\n}\n\nconst userInput = data.user_input || '';\nconst fitnessData = extractFitnessData(userInput);\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Determine activity from router or extraction\nconst activity = data.Activity || fitnessData.activity;\nconst workoutType = data.workout_type || fitnessData.activity;\n\n// Handle Time/weight field properly\nlet timeWeight = null;\nlet metricType = null;\n\nif (fitnessData.distance) {\n  timeWeight = fitnessData.distance;\n  metricType = 'Distance';\n} else if (data['Time/weight']) {\n  timeWeight = parseFloat(data['Time/weight']);\n  metricType = data.MetricType || 'Distance';\n}\n\n// Duration handling\nconst duration = parseInt(data.duration_minutes) || fitnessData.duration;\n\n// Missed workout detection\nlet missedWorkout = null;\nlet excuseIfMissed = null;\n\nif (userInput.match(/\\b(missed|skipped|didn't|couldn't)\\b/i)) {\n  missedWorkout = true;\n  if (userInput.match(/\\b(tired|exhausted)\\b/i)) excuseIfMissed = 'too tired';\n  else if (userInput.match(/\\b(busy|work|meeting)\\b/i)) excuseIfMissed = 'too busy';\n  else if (userInput.match(/\\b(sore|pain|hurt)\\b/i)) excuseIfMissed = 'too sore';\n  else if (userInput.match(/\\b(sick|ill|unwell)\\b/i)) excuseIfMissed = 'sick';\n}\n\n// Confidence calculation\nlet confidence = data.confidence_level || 0.5;\nif (activity && duration && timeWeight) confidence = 0.9;\nelse if (activity && (duration || timeWeight)) confidence = 0.8;\nelse if (activity) confidence = 0.7;\n\nreturn {\n  user_input: data.user_input || null,\n  Activity: activity ? activity.charAt(0).toUpperCase() + activity.slice(1) : null,\n  'Time/weight': timeWeight,\n  MetricType: metricType,\n  current_value: data.current_value || null,\n  workout_type: workoutType,\n  duration_minutes: duration,\n  intensity: fitnessData.intensity || parseInt(data.intensity) || null,\n  energy_before: parseInt(data.energy_before) || null,\n  energy_after: fitnessData.energy_after || parseInt(data.energy_after) || null,\n  workout_time: fitnessData.workout_time || data.workout_time || null,\n  missed_planned_workout: missedWorkout,\n  excuse_if_missed: excuseIfMissed,\n  productivity_score_after: parseInt(data.productivity_score_after) || null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -2320
      ],
      "id": "38fa0091-30c1-4b18-97f3-efda765ed443",
      "name": "Prepare Fitness"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO health (\n  user_id, \n  \"user input\", \n  \"SleepHours\", \n  \"Calorie intake\", \n  \"Vitamin intake\",\n  sleep_hours, \n  sleep_quality, \n  meals_count, \n  water_liters, \n  caffeine_intake,\n  stress_level, \n  screen_time_hours, \n  energy_crashes, \n  took_breaks, \n  mental_clarity,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.SleepHours !== undefined && $json.SleepHours !== null ? $json.SleepHours : 'NULL' }},\n  {{ $json['Calorie intake'] !== undefined && $json['Calorie intake'] !== null ? $json['Calorie intake'] : 'NULL' }},\n  {{ $json['Vitamin intake'] ? \"'\" + $json['Vitamin intake'].replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.sleep_hours !== undefined && $json.sleep_hours !== null ? $json.sleep_hours : 'NULL' }},\n  {{ $json.sleep_quality !== undefined && $json.sleep_quality !== null ? $json.sleep_quality : 'NULL' }},\n  {{ $json.meals_count !== undefined && $json.meals_count !== null ? $json.meals_count : 'NULL' }},\n  {{ $json.water_liters !== undefined && $json.water_liters !== null ? $json.water_liters : 'NULL' }},\n  {{ $json.caffeine_intake !== undefined && $json.caffeine_intake !== null ? $json.caffeine_intake : 'NULL' }},\n  {{ $json.stress_level !== undefined && $json.stress_level !== null ? $json.stress_level : 'NULL' }},\n  {{ $json.screen_time_hours !== undefined && $json.screen_time_hours !== null ? $json.screen_time_hours : 'NULL' }},\n  {{ $json.energy_crashes ? \"'\" + $json.energy_crashes.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.took_breaks !== undefined && $json.took_breaks !== null ? $json.took_breaks : 'NULL' }},\n  {{ $json.mental_clarity !== undefined && $json.mental_clarity !== null ? $json.mental_clarity : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -2120
      ],
      "id": "00519d7f-8f1e-432c-88fe-cf570f3229a1",
      "name": "Insert Health",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO emotions (\n  user_id, \n  \"user input\", \n  fears, \n  emotions, \n  topic, \n  insecurities,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.fears ? \"'\" + $json.fears.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.emotions ? \"'\" + $json.emotions.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.topic ? \"'\" + $json.topic.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.insecurities ? \"'\" + $json.insecurities.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -1920
      ],
      "id": "5fcf7365-c3ea-4916-82cf-98bff4a178af",
      "name": "Insert Emotions",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO family (\n  user_id, \n  \"user input\", \n  interaction_type, \n  duration_minutes, \n  present_vs_distracted,\n  relationship_affected, \n  work_interrupted, \n  guilt_level, \n  happiness_impact,\n  planned_vs_spontaneous,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.interaction_type ? \"'\" + $json.interaction_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.duration_minutes !== undefined && $json.duration_minutes !== null ? $json.duration_minutes : 'NULL' }},\n  {{ $json.present_vs_distracted !== undefined && $json.present_vs_distracted !== null ? $json.present_vs_distracted : 'NULL' }},\n  {{ $json.relationship_affected ? \"'\" + $json.relationship_affected.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.work_interrupted !== undefined && $json.work_interrupted !== null ? $json.work_interrupted : 'NULL' }},\n  {{ $json.guilt_level !== undefined && $json.guilt_level !== null ? $json.guilt_level : 'NULL' }},\n  {{ $json.happiness_impact !== undefined && $json.happiness_impact !== null ? $json.happiness_impact : 'NULL' }},\n  {{ $json.planned_vs_spontaneous ? \"'\" + $json.planned_vs_spontaneous.replace(/'/g, \"''\") + \"'\" : \"'spontaneous'\" }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -1720
      ],
      "id": "bc9f96ea-aa8b-4571-a11f-11cac3ef9340",
      "name": "Insert Family",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO leverage (\n  user_id, \n  \"user input\", \n  leverage_type, \n  time_saved_hours, \n  cost_invested,\n  revenue_impact, \n  implementation_difficulty, \n  still_using, \n  failure_reason,\n  multiplier_effect, \n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.leverage_type ? \"'\" + $json.leverage_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.time_saved_hours !== undefined && $json.time_saved_hours !== null ? $json.time_saved_hours : 'NULL' }},\n  {{ $json.cost_invested !== undefined && $json.cost_invested !== null ? $json.cost_invested : 'NULL' }},\n  {{ $json.revenue_impact !== undefined && $json.revenue_impact !== null ? $json.revenue_impact : 'NULL' }},\n  {{ $json.implementation_difficulty !== undefined && $json.implementation_difficulty !== null ? $json.implementation_difficulty : 'NULL' }},\n  {{ $json.still_using !== undefined && $json.still_using !== null ? $json.still_using : 'NULL' }},\n  {{ $json.failure_reason ? \"'\" + $json.failure_reason.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.multiplier_effect !== undefined && $json.multiplier_effect !== null ? $json.multiplier_effect : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -1520
      ],
      "id": "da15f9d7-c143-4b6f-b228-a227856c1dea",
      "name": "Insert Leverage",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\n// Enhanced metadata storage\nconst metadata = {\n  emotional_signals: emotions,\n  suggestion_accepted: data.suggestion_accepted,\n  feedback_sentiment: data.feedback_sentiment,\n  reasoning_provided: data.reasoning_provided,\n  has_context: data.has_context,\n  system_sentiment: data.system_sentiment,\n  nps_indicator: data.nps_indicator,\n  request_type: data.request_type,\n  impact_reported: data.impact_reported,\n  transformation_language: data.transformation_language,\n  brand_alignment: data.brand_alignment\n};\n\n// Pattern detection from user response\nlet patternDetected = data.pattern_detected;\nif (!patternDetected) {\n  if (userInput.match(/\\b(no|don't|won't|can't|hate)\\b/i)) {\n    patternDetected = 'negative_response';\n  } else if (userInput.match(/\\b(yes|ok|sure|thanks|helpful)\\b/i)) {\n    patternDetected = 'positive_response';\n  } else if (userInput.match(/\\b(but|however|except)\\b/i)) {\n    patternDetected = 'qualified_response';\n  } else if (userInput.match(/\\?/)) {\n    patternDetected = 'question_response';\n  }\n}\n\n// Confidence\nlet confidence = data.assumption_confidence || data.confidence_level || 0.5;\nif (data.suggestion_accepted !== undefined) confidence = 0.9;\n\nreturn {\n  user_input: data.user_input || null,\n  sessionID: data.sessionID || $node[\"Async Entry1\"].json.body.sessionID,\n  category: data.category || 'general',\n  ai_response: data.ai_response || data.ai_context || null,\n  pattern_detected: patternDetected,\n  assumption_delivered: data.assumption_delivered !== undefined ? data.assumption_delivered : false,\n  assumption_id: data.assumption_id || null,\n  assumption_confidence: confidence,\n  user_stage: data.user_stage || null,\n  metadata: JSON.stringify(metadata)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -720
      ],
      "id": "fe069dd0-6446-4051-90c7-7aec3b10335c",
      "name": "Prepare User Feedback"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO goals (\n  user_id, \n  user_input, \n  target_value, \n  unit_of_measurement, \n  goal_type,\n  current_value, \n  deadline, \n  priority, \n  status, \n  active_goals,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.target_value !== undefined && $json.target_value !== null ? $json.target_value : 'NULL' }},\n  {{ $json.unit_of_measurement ? \"'\" + $json.unit_of_measurement.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.goal_type ? \"'\" + $json.goal_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.current_value ? \"'\" + $json.current_value.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.deadline ? \"'\" + $json.deadline.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.priority !== undefined && $json.priority !== null ? $json.priority : 'NULL' }},\n  {{ $json.status ? \"'\" + $json.status.replace(/'/g, \"''\") + \"'\" : \"'active'\" }},\n  {{ $json.active_goals ? \"'\" + $json.active_goals.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -1320
      ],
      "id": "2704e2ae-9f8a-420f-b888-3fd0ad389a54",
      "name": "Insert Goals",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nreturn {\n  user_input: data.user_input || null,\n  confidence_level: data.confidence_level || 0.5,\n  emotional_signals: JSON.stringify(extractDeepEmotionalSignals(data.user_input || ''))\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -1120
      ],
      "id": "131b96c7-f17a-41e6-a044-fcaa2678f46d",
      "name": "Prepare Routine"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO routine (\n  user_id, \n  \"user input\",\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  '{{ $json.emotional_signals }}'::text\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -1120
      ],
      "id": "2f0e8870-30fa-4c42-b7d6-5564e2756416",
      "name": "Insert Routine",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nconst emotions = extractDeepEmotionalSignals(data.content || data.user_input || '');\n\n// Enhanced metadata\nconst metadata = {\n  ...data.metadata,\n  emotional_signals: emotions,\n  interaction_quality: emotions.length > 2 ? 'high_engagement' : 'normal',\n  timestamp: new Date().toISOString()\n};\n\n// Pattern detection\nlet pattern = data.pattern_detected;\nif (!pattern && data.content) {\n  const content = data.content.toLowerCase();\n  if (content.match(/\\b(always|every|keeps|again)\\b/)) pattern = 'recurring';\n  else if (content.match(/\\b(help|support|need|question)\\b/)) pattern = 'seeking_help';\n  else if (content.match(/\\b(thanks|great|awesome|love)\\b/)) pattern = 'positive_feedback';\n  else if (content.match(/\\b(no|don't|won't|hate)\\b/)) pattern = 'negative_feedback';\n}\n\nreturn {\n  user_id: data.user_id || $node[\"Async Entry1\"].json.body.userID,\n  session_id: data.session_id || $node[\"Async Entry1\"].json.body.sessionID,\n  interaction_type: data.interaction_type || 'text-chat',\n  content: data.content || data.user_input || null,\n  category: data.category || 'general',\n  pattern_detected: pattern,\n  metadata: JSON.stringify(metadata),\n  confidence_level: data.confidence_level || 1.0,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -3100
      ],
      "id": "ff6dddc0-62fe-46c2-bde0-d87d5ee65eb8",
      "name": "Prepare Recent Interactions"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO user_feedback (\n  user_id, \n  \"sessionID\", \n  category, \n  user_input, \n  ai_response,\n  pattern_detected,\n  assumption_delivered,\n  assumption_id,\n  assumption_confidence,\n  user_stage,\n  metadata\n)\nVALUES (\n  '{{ $node['Async Entry1'].json.body.userID }}',\n  {{ $json.sessionID ? \"'\" + $json.sessionID.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.category ? \"'\" + $json.category.replace(/'/g, \"''\") + \"'\" : \"'general'\" }},\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.ai_response ? \"'\" + $json.ai_response.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.pattern_detected ? \"'\" + $json.pattern_detected.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.assumption_delivered !== undefined && $json.assumption_delivered !== null ? $json.assumption_delivered : 'NULL' }},\n  {{ $json.assumption_id !== undefined ? $json.assumption_id : 'NULL' }},\n  {{ $json.assumption_confidence || 0.5 }},\n  {{ $json.user_stage ? \"'\" + $json.user_stage.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.metadata ? \"'\" + $json.metadata.replace(/'/g, \"''\") + \"'::jsonb\" : \"'{}'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -720
      ],
      "id": "e94b0434-3306-4678-955a-7cc562ee51d9",
      "name": "Insert User Feedback",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO unknown_interactions (\n   user_id,\n   \"user input\",\n   reason_unclassified,\n   potential_categories,\n   ai_reply,\n   confidence_level,\n   emotional_signals\n) VALUES (\n   '{{ $node[\"Async Entry1\"].json.body.userID }}',\n   {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n   {{ $json.reason_unclassified ? \"'\" + $json.reason_unclassified.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n   {{ $json.potential_categories && $json.potential_categories.length > 0 ? \"ARRAY[\" + $json.potential_categories.map(cat => \"'\" + cat.replace(/'/g, \"''\") + \"'\").join(\", \") + \"]\" : 'NULL' }},\n   {{ $json.ai_context ? \"'\" + $json.ai_context.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n   {{ $json.confidence_level || 0.1 }},\n   {{ $json.emotional_signals ? \"'\" + JSON.stringify($json.emotional_signals) + \"'::jsonb\" : 'NULL' }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        1700
      ],
      "id": "b5bcf405-4136-4af1-b6b1-6f4e4d049121",
      "name": "Insert Unknown Table",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\nconst data = $json.data;\n\n// Include helper functions\n\nconst emotions = extractDeepEmotionalSignals(data.user_input || '');\n\n// Try to determine why it was unclassified\nlet reason = data.reason_unclassified || 'unknown';\nlet potentialCategories = data.potential_categories || [];\n\nif (data.user_input) {\n  const input = data.user_input.toLowerCase();\n  \n  // Check for potential categories it might belong to\n  if (input.match(/\\b(money|revenue|sales|deal)\\b/)) potentialCategories.push('business:sales');\n  if (input.match(/\\b(sleep|stress|health|tired)\\b/)) potentialCategories.push('health');\n  if (input.match(/\\b(workout|gym|exercise|run)\\b/)) potentialCategories.push('fitness');\n  if (input.match(/\\b(family|wife|husband|kids)\\b/)) potentialCategories.push('family');\n  \n  // Determine reason\n  if (input.length < 10) reason = 'too_short';\n  else if (!input.match(/[a-zA-Z]/)) reason = 'no_text';\n  else if (potentialCategories.length > 3) reason = 'too_ambiguous';\n  else if (potentialCategories.length === 0) reason = 'no_matching_patterns';\n}\n\nreturn {\n  user_input: data.user_input || null,\n  reason_unclassified: reason,\n  potential_categories: potentialCategories,\n  ai_context: data.ai_context || null,\n  confidence_level: data.confidence_level || 0.1,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        1700
      ],
      "id": "f4408d5c-75bc-48d4-8710-ef60cd5cf152",
      "name": "Handle Unknown Tables5"
    },
    {
      "parameters": {
        "content": "## Incoming",
        "height": 120,
        "width": 220,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        520,
        80
      ],
      "id": "badc4878-a328-4d52-8aae-1f7dc8545257",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "## Storage",
        "height": 120,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1360,
        140
      ],
      "id": "ad2f3a69-6528-4063-98e2-a0e750aeba90",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "## Filter",
        "height": 120
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1120,
        140
      ],
      "id": "883a31b7-5287-47a8-a930-798440857729",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## Router",
        "height": 120,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        740,
        80
      ],
      "id": "9b961e42-56fc-4b9b-a388-28d43c15541f",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "## Merge",
        "height": 120,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1760,
        80
      ],
      "id": "10840544-7a55-4681-9820-37d822170680",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "## Error pick up",
        "height": 120,
        "width": 220,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2180,
        80
      ],
      "id": "0dcb60ae-5940-437b-9ec8-0a6c23219a9f",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "",
        "height": 520,
        "width": 220,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        520,
        -420
      ],
      "id": "3bd2f214-4303-4d21-9b05-bd1ce6dacebe",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "content": "",
        "height": 5080,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1360,
        -3180
      ],
      "id": "b6f8f7f4-f548-4605-9da7-c0706335781d",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "content": "",
        "height": 5080
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1120,
        -3180
      ],
      "id": "01c359ce-be83-4ddc-b15c-e5188a4e2eb5",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "",
        "height": 1080,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        740,
        -960
      ],
      "id": "51621113-8d45-4063-9ad7-b4c2f74c161e",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "content": "",
        "height": 1060,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1760,
        -960
      ],
      "id": "09f37469-a976-4743-b72e-d5ee6bc36cba",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "",
        "height": 680,
        "width": 220,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2180,
        -580
      ],
      "id": "d9d181da-da3b-4f2a-baa2-fdf24db8a04f",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "content": "## DATA EXTRACTION WORKFLOW\n",
        "height": 840,
        "width": 1040,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -60,
        -980
      ],
      "id": "5adf5634-6473-4d66-ba69-903386e33c72",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "",
        "height": 840,
        "width": 740,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1760,
        -980
      ],
      "id": "4a9ea6ef-9b54-46dc-9a6a-33ab8596faaa",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "content": "",
        "height": 5140,
        "width": 800,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        940,
        -3220
      ],
      "id": "fddec18b-50d0-4838-82a4-d6ee2625304b",
      "name": "Sticky Note15"
    },
    {
      "parameters": {
        "content": "## Previous Message Context",
        "height": 200,
        "width": 480,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -220,
        -620
      ],
      "id": "832d2b80-3a57-4cf6-9a4c-05f605893bcb",
      "name": "Sticky Note16"
    },
    {
      "parameters": {
        "content": "## ENGINE",
        "height": 640,
        "width": 220,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        520,
        -1060
      ],
      "id": "785d0bff-e9d9-4214-92cd-bd0827720886",
      "name": "Sticky Note17"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n\n// MONEY VALUE PARSER\nfunction parseMoneyValue(value) {\n  if (!value) return null;\n  \n  // Remove common currency symbols and formatting\n  let cleanValue = value.toString().replace(/[$,£€¥]/g, '');\n  \n  // Handle 'k' notation (thousands)\n  if (cleanValue.toLowerCase().includes('k')) {\n    cleanValue = cleanValue.toLowerCase().replace('k', '');\n    return parseFloat(cleanValue) * 1000;\n  }\n  \n  // Handle 'm' notation (millions)\n  if (cleanValue.toLowerCase().includes('m')) {\n    cleanValue = cleanValue.toLowerCase().replace('m', '');\n    return parseFloat(cleanValue) * 1000000;\n  }\n  \n  return parseFloat(cleanValue) || null;\n}\n\n// ===== PREPARE BUSINESS MODELS (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractBusinessModelMetrics(text) {\n  const metrics = {};\n  \n  // Revenue model patterns\n  const revenuePatterns = [\n    /(?:revenue|making|earning).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i,\n    /\\$?([0-9,]+(?:\\.[0-9]+)?k?).*?(?:revenue|income|profit)/i,\n    /(?:monthly|per month).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i\n  ];\n  for (const pattern of revenuePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.monthly_revenue = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // Customer count - \"500 customers\", \"250 users\", \"1k clients\"\n  const customerPatterns = [\n    /([0-9,]+k?)\\s*(?:customers?|users?|clients?|buyers?)/i,\n    /(?:have|got|serving).*?([0-9,]+k?).*?(?:customers?|users?|clients?)/i,\n    /([0-9,]+k?).*?(?:active|paying).*?(?:customers?|users?)/i\n  ];\n  for (const pattern of customerPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let count = match[1].replace(/,/g, '');\n      if (count.includes('k')) {\n        count = parseFloat(count.replace('k', '')) * 1000;\n      } else {\n        count = parseInt(count);\n      }\n      metrics.customer_count = count;\n      break;\n    }\n  }\n  \n  // Unit economics - CLTV, CAC\n  const cltvPatterns = [\n    /(?:cltv|lifetime value|ltv).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i,\n    /\\$?([0-9,]+(?:\\.[0-9]+)?k?).*?(?:cltv|lifetime|ltv)/i\n  ];\n  for (const pattern of cltvPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.customer_lifetime_value = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  const cacPatterns = [\n    /(?:cac|acquisition cost|customer cost).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i,\n    /\\$?([0-9,]+(?:\\.[0-9]+)?k?).*?(?:cac|acquisition|to acquire)/i\n  ];\n  for (const pattern of cacPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.customer_acquisition_cost = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // Profit margin\n  const marginPatterns = [\n    /([0-9.]+)%?\\s*(?:margin|profit)/i,\n    /(?:margin|profit).*?([0-9.]+)%/i,\n    /([0-9.]+)\\s*percent.*?(?:margin|profit)/i\n  ];\n  for (const pattern of marginPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.profit_margin_percentage = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Growth rate\n  const growthPatterns = [\n    /([0-9.]+)%?\\s*(?:growth|growing|increase)/i,\n    /(?:growth|growing).*?([0-9.]+)%/i,\n    /(?:up|increased).*?([0-9.]+)%/i,\n    /([0-9.]+)%?\\s*(?:mom|yoy|monthly|yearly)/i\n  ];\n  for (const pattern of growthPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.growth_rate_percentage = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Business model type detection\nlet businessModelType = null;\nif (userInput.match(/\\b(subscription|recurring|monthly|saas|sub)\\b/i)) {\n  businessModelType = 'subscription';\n} else if (userInput.match(/\\b(marketplace|platform|commission|take rate)\\b/i)) {\n  businessModelType = 'marketplace';\n} else if (userInput.match(/\\b(freemium|free tier|premium|upgrade)\\b/i)) {\n  businessModelType = 'freemium';\n} else if (userInput.match(/\\b(licensing|license|royalty|franchise)\\b/i)) {\n  businessModelType = 'licensing';\n} else if (userInput.match(/\\b(advertising|ads|ad revenue|sponsors)\\b/i)) {\n  businessModelType = 'advertising';\n} else if (userInput.match(/\\b(transaction|per transaction|payment processing)\\b/i)) {\n  businessModelType = 'transaction_fee';\n} else if (userInput.match(/\\b(one time|single purchase|product sales?)\\b/i)) {\n  businessModelType = 'one_time_purchase';\n} else if (userInput.match(/\\b(consulting|service|hourly|project)\\b/i)) {\n  businessModelType = 'service_based';\n}\n\n// Revenue streams detection\nconst revenueStreams = [];\nif (userInput.match(/\\b(product sales?|selling products?)\\b/i)) revenueStreams.push('product_sales');\nif (userInput.match(/\\b(service|consulting|done for you)\\b/i)) revenueStreams.push('services');\nif (userInput.match(/\\b(subscription|recurring|monthly)\\b/i)) revenueStreams.push('subscriptions');\nif (userInput.match(/\\b(advertising|ads|sponsored)\\b/i)) revenueStreams.push('advertising');\nif (userInput.match(/\\b(affiliate|commission|referral)\\b/i)) revenueStreams.push('affiliates');\nif (userInput.match(/\\b(licensing|royalty|franchise)\\b/i)) revenueStreams.push('licensing');\nif (userInput.match(/\\b(course|training|education)\\b/i)) revenueStreams.push('education');\n\n// Scalability assessment (1-10 scale)\nlet scalability = 5; // default medium\nif (userInput.match(/\\b(highly scalable|very scalable|infinite scale|fully automated)\\b/i)) {\n  scalability = 9;\n} else if (userInput.match(/\\b(scalable|can scale|easy to scale)\\b/i)) {\n  scalability = 7;\n} else if (userInput.match(/\\b(somewhat scalable|limited scale)\\b/i)) {\n  scalability = 4;\n} else if (userInput.match(/\\b(hard to scale|difficult scale|not scalable|manual)\\b/i)) {\n  scalability = 2;\n}\n\n// Competition level (1-10 scale)\nlet competitionLevel = 5; // default medium\nif (userInput.match(/\\b(highly competitive|very competitive|saturated|crowded)\\b/i)) {\n  competitionLevel = 8;\n} else if (userInput.match(/\\b(competitive|some competition)\\b/i)) {\n  competitionLevel = 6;\n} else if (userInput.match(/\\b(niche|little competition|few competitors)\\b/i)) {\n  competitionLevel = 3;\n} else if (userInput.match(/\\b(no competition|first to market|unique)\\b/i)) {\n  competitionLevel = 1;\n}\n\n// Funding status\nlet fundingStatus = null;\nif (userInput.match(/\\b(bootstrapped|self funded|own money)\\b/i)) {\n  fundingStatus = 'bootstrapped';\n} else if (userInput.match(/\\b(angel|angel investor|angel round)\\b/i)) {\n  fundingStatus = 'angel';\n} else if (userInput.match(/\\b(seed|seed round|seed funding)\\b/i)) {\n  fundingStatus = 'seed';\n} else if (userInput.match(/\\b(series a|a round)\\b/i)) {\n  fundingStatus = 'series_a';\n} else if (userInput.match(/\\b(venture|vc|venture capital)\\b/i)) {\n  fundingStatus = 'venture';\n} else if (userInput.match(/\\b(loan|debt|bank)\\b/i)) {\n  fundingStatus = 'debt';\n}\n\n// Time to break even\nlet breakEvenMonths = null;\nconst breakEvenMatch = userInput.match(/(?:break even|profitable).*?(\\d+)\\s*(?:months?|weeks?)/i);\nif (breakEvenMatch) {\n  let months = parseInt(breakEvenMatch[1]);\n  if (userInput.includes('week')) months = Math.ceil(months / 4);\n  breakEvenMonths = months;\n}\n\nconst metrics = extractBusinessModelMetrics(userInput);\nconst dateTime = extractDateTime(userInput);\n\n// Calculate confidence\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (businessModelType && metricCount >= 3) confidence = 0.9;\nelse if (businessModelType && metricCount >= 2) confidence = 0.8;\nelse if (businessModelType || metricCount >= 2) confidence = 0.7;\nelse if (metricCount >= 1) confidence = 0.6;\n\nreturn {\n  user_input: userInput,\n  business_model_type: businessModelType,\n  revenue_streams: revenueStreams.length > 0 ? revenueStreams : null,\n  monthly_revenue: metrics.monthly_revenue || null,\n  customer_count: metrics.customer_count || null,\n  customer_lifetime_value: metrics.customer_lifetime_value || null,\n  customer_acquisition_cost: metrics.customer_acquisition_cost || null,\n  profit_margin_percentage: metrics.profit_margin_percentage || null,\n  growth_rate_percentage: metrics.growth_rate_percentage || null,\n  scalability_score: scalability,\n  competition_level: competitionLevel,\n  funding_status: fundingStatus,\n  time_to_break_even_months: breakEvenMonths,\n  target_launch_date: dateTime.date,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        1480
      ],
      "id": "d650c7c5-1bca-454a-a242-9689372bb273",
      "name": "Prepare Business Models"
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n// ===== PREPARE BUSINESS ECOMMERCE (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractEcommerceMetrics(text) {\n  const metrics = {};\n  \n  // AOV patterns - \"$45 aov\", \"average order 67\", \"aov is $32\"\n  const aovPatterns = [\n    /(?:aov|average order|order value).*?\\$?([\\d,]+(?:\\.\\d+)?)/i,\n    /\\$?([\\d,]+(?:\\.\\d+)?).*?(?:aov|average order)/i,\n    /(?:orders averaging|avg order).*?\\$?([\\d,]+(?:\\.\\d+)?)/i\n  ];\n  for (const pattern of aovPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.average_order_value = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // Conversion rate - \"3.2%\", \"3.2 percent\", \"converting at 3%\"\n  const convPatterns = [\n    /([\\d.]+)%?\\s*(?:conversion|converting|convert)/i,\n    /(?:conversion|converting).*?([\\d.]+)%/i,\n    /([\\d.]+)\\s*percent.*?conver/i\n  ];\n  for (const pattern of convPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.conversion_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Cart abandonment - \"70% abandon\", \"cart abandonment 65%\"\n  const cartPatterns = [\n    /([\\d.]+)%?\\s*(?:abandon|cart abandon|left cart)/i,\n    /(?:abandon|cart abandon).*?([\\d.]+)%/i,\n    /(?:leaving|abandoning).*?([\\d.]+)%/i\n  ];\n  for (const pattern of cartPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.cart_abandonment_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Inventory count - \"500 products\", \"250 items in stock\"\n  const invPatterns = [\n    /(\\d+)\\s*(?:products|items|sku|skus|listings)/i,\n    /(?:inventory|stock).*?(\\d+)/i,\n    /(\\d+).*?(?:in stock|available)/i\n  ];\n  for (const pattern of invPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.inventory_count = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Return rate\n  const returnPatterns = [\n    /([\\d.]+)%?\\s*(?:return|returns|refund)/i,\n    /(?:return|refund).*?([\\d.]+)%/i\n  ];\n  for (const pattern of returnPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.return_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Product category detection\nlet productCategory = null;\nif (userInput.match(/\\b(physical|shipped|shipping|warehouse|3pl|fulfillment|box)\\b/i)) {\n  productCategory = 'physical';\n} else if (userInput.match(/\\b(digital|download|pdf|course|ebook|software|app)\\b/i)) {\n  productCategory = 'digital';\n} else if (userInput.match(/\\b(subscription box|monthly box|recurring box|sub box)\\b/i)) {\n  productCategory = 'subscription_box';\n} else if (userInput.match(/\\b(service|consulting|done for you|dfy)\\b/i)) {\n  productCategory = 'services';\n}\n\n// Traffic sources extraction\nconst trafficSources = [];\nif (userInput.match(/\\b(organic|seo|search)\\b/i)) trafficSources.push('organic');\nif (userInput.match(/\\b(paid ads|facebook ads|google ads|ppc)\\b/i)) trafficSources.push('paid_ads');\nif (userInput.match(/\\b(email|newsletter)\\b/i)) trafficSources.push('email');\nif (userInput.match(/\\b(social|instagram|tiktok|facebook)\\b/i)) trafficSources.push('social');\nif (userInput.match(/\\b(referral|word of mouth|wom)\\b/i)) trafficSources.push('referral');\n\n// Fulfillment time\nlet fulfillmentTime = null;\nconst fulfillmentMatch = userInput.match(/(\\d+)\\s*(?:days?|business days?)\\s*(?:shipping|fulfillment|to ship)/i);\nif (fulfillmentMatch) fulfillmentTime = parseInt(fulfillmentMatch[1]);\n\n// Seasonal patterns\nlet seasonalPatterns = null;\nif (userInput.match(/\\b(q4|christmas|holiday|black friday|cyber monday)\\b/i)) {\n  seasonalPatterns = 'Q4 spike';\n} else if (userInput.match(/\\b(summer|spring|seasonal)\\b/i)) {\n  seasonalPatterns = 'seasonal';\n}\n\nconst metrics = extractEcommerceMetrics(userInput);\n\n// Calculate confidence\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (metricCount >= 3) confidence = 0.9;\nelse if (metricCount >= 2) confidence = 0.8;\nelse if (metricCount >= 1) confidence = 0.7;\n\nif (productCategory) confidence = Math.min(confidence + 0.1, 1.0);\n\nreturn {\n  user_input: userInput,\n  product_category: productCategory,\n  inventory_count: metrics.inventory_count || null,\n  conversion_rate: metrics.conversion_rate || null,\n  average_order_value: metrics.average_order_value || null,\n  cart_abandonment_rate: metrics.cart_abandonment_rate || null,\n  return_rate: metrics.return_rate || null,\n  fulfillment_time_days: fulfillmentTime,\n  traffic_sources: trafficSources.length > 0 ? trafficSources : null,\n  seasonal_patterns: seasonalPatterns,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -280
      ],
      "id": "e636c83a-6fc8-4032-9412-c7dec89bc347",
      "name": "Prepare Business Ecom"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:ecommerce\" (\n  user_id,\n  \"user input\",\n  product_category,\n  inventory_count,\n  products_listed,\n  conversion_rate,\n  average_order_value,\n  cart_abandonment_rate,\n  return_rate,\n  fulfillment_time_days,\n  customer_acquisition_cost,\n  lifetime_value,\n  traffic_sources,\n  bestselling_product,\n  inventory_turnover_rate,\n  seasonal_patterns,\n  supplier_reliability,\n  shipping_cost_percentage,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.product_category ? \"'\" + $json.product_category.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.inventory_count !== undefined && $json.inventory_count !== null ? $json.inventory_count : 'NULL' }},\n  {{ $json.products_listed !== undefined && $json.products_listed !== null ? $json.products_listed : 'NULL' }},\n  {{ $json.conversion_rate !== undefined && $json.conversion_rate !== null ? $json.conversion_rate : 'NULL' }},\n  {{ $json.average_order_value !== undefined && $json.average_order_value !== null ? $json.average_order_value : 'NULL' }},\n  {{ $json.cart_abandonment_rate !== undefined && $json.cart_abandonment_rate !== null ? $json.cart_abandonment_rate : 'NULL' }},\n  {{ $json.return_rate !== undefined && $json.return_rate !== null ? $json.return_rate : 'NULL' }},\n  {{ $json.fulfillment_time_days !== undefined && $json.fulfillment_time_days !== null ? $json.fulfillment_time_days : 'NULL' }},\n  {{ $json.customer_acquisition_cost !== undefined && $json.customer_acquisition_cost !== null ? $json.customer_acquisition_cost : 'NULL' }},\n  {{ $json.lifetime_value !== undefined && $json.lifetime_value !== null ? $json.lifetime_value : 'NULL' }},\n  {{ $json.traffic_sources ? \"ARRAY[\" + $json.traffic_sources.map(source => \"'\" + source.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.bestselling_product ? \"'\" + $json.bestselling_product.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.inventory_turnover_rate !== undefined && $json.inventory_turnover_rate !== null ? $json.inventory_turnover_rate : 'NULL' }},\n  {{ $json.seasonal_patterns ? \"'\" + $json.seasonal_patterns.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.supplier_reliability !== undefined && $json.supplier_reliability !== null ? $json.supplier_reliability : 'NULL' }},\n  {{ $json.shipping_cost_percentage !== undefined && $json.shipping_cost_percentage !== null ? $json.shipping_cost_percentage : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -280
      ],
      "id": "f0fa5856-d4cc-4194-908a-db6edac731d2",
      "name": "Insert Business Ecom",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:models\" (\n  user_id,\n  business_type,\n  revenue_model,\n  primary_channels,\n  target_market,\n  monthly_revenue_range,\n  business_stage,\n  team_size,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.business_model_type ? \"'\" + $json.business_model_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.revenue_streams && $json.revenue_streams.length > 0 ? \"'\" + $json.revenue_streams[0].replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.revenue_streams ? \"ARRAY[\" + $json.revenue_streams.map(stream => \"'\" + stream.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.target_market ? \"'\" + $json.target_market.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.monthly_revenue ? \n    ($json.monthly_revenue >= 100000 ? \"'$100k+'\" :\n     $json.monthly_revenue >= 50000 ? \"'$50k-$100k'\" :\n     $json.monthly_revenue >= 25000 ? \"'$25k-$50k'\" :\n     $json.monthly_revenue >= 10000 ? \"'$10k-$25k'\" :\n     $json.monthly_revenue >= 5000 ? \"'$5k-$10k'\" :\n     $json.monthly_revenue >= 1000 ? \"'$1k-$5k'\" : \"'<$1k'\") : 'NULL' }},\n  {{ $json.business_stage ? \"'\" + $json.business_stage.replace(/'/g, \"''\") + \"'\" : \n     ($json.customer_count && $json.customer_count > 1000 ? \"'scaling'\" :\n      $json.customer_count && $json.customer_count > 100 ? \"'growth'\" :\n      $json.monthly_revenue && $json.monthly_revenue > 0 ? \"'launch'\" : \"'idea'\") }},\n  {{ $json.team_size !== undefined && $json.team_size !== null ? $json.team_size : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        1480
      ],
      "id": "8d90c0a2-edfb-43be-852b-894c233bc11b",
      "name": "Insert Business Models",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n// ===== PREPARE BUSINESS SAAS (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractSaasMetrics(text) {\n  const metrics = {};\n  \n  // MRR patterns - \"mrr is $5k\", \"$3200 mrr\", \"monthly recurring 2500\"\n  const mrrPatterns = [\n    /(?:mrr|monthly recurring).*?\\$?([\\d,]+(?:\\.\\d+)?k?)/i,\n    /\\$?([\\d,]+(?:\\.\\d+)?k?).*?(?:mrr|monthly recurring)/i,\n    /(?:recurring revenue).*?\\$?([\\d,]+(?:\\.\\d+)?k?)/i\n  ];\n  for (const pattern of mrrPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.monthly_recurring_revenue = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // ARR patterns\n  const arrPatterns = [\n    /(?:arr|annual recurring).*?\\$?([\\d,]+(?:\\.\\d+)?k?)/i,\n    /\\$?([\\d,]+(?:\\.\\d+)?k?).*?(?:arr|annual recurring)/i\n  ];\n  for (const pattern of arrPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.annual_recurring_revenue = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // Churn rate - \"5% churn\", \"churn is 3.2%\", \"losing 4% monthly\"\n  const churnPatterns = [\n    /([\\d.]+)%?\\s*(?:churn|cancel|churning|leaving)/i,\n    /(?:churn|cancel|turnover).*?([\\d.]+)%/i,\n    /(?:losing|lost).*?([\\d.]+)%.*?(?:monthly|users|customers)/i\n  ];\n  for (const pattern of churnPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.churn_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Active subscribers - \"500 subscribers\", \"250 paying users\"\n  const subPatterns = [\n    /(\\d+)\\s*(?:subscribers|users|customers|paying|active)/i,\n    /(?:have|got).*?(\\d+).*?(?:subscribers|users|customers)/i\n  ];\n  for (const pattern of subPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.active_subscribers = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // New signups - \"50 new signups\", \"25 registrations this week\"\n  const signupPatterns = [\n    /(\\d+)\\s*(?:new|fresh)?\\s*(?:signups|registrations|users|sign.?ups)/i,\n    /(?:signed up|registered).*?(\\d+)/i,\n    /(\\d+).*?(?:joined|new users)/i\n  ];\n  for (const pattern of signupPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.new_signups = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Trial conversion - \"15% trial conversion\", \"convert 12% of trials\"\n  const trialPatterns = [\n    /([\\d.]+)%?\\s*(?:trial.*convert|convert.*trial)/i,\n    /(?:trial|free).*?convert.*?([\\d.]+)%/i,\n    /([\\d.]+)%.*?(?:trials|free users).*?(?:convert|upgrade)/i\n  ];\n  for (const pattern of trialPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.trial_to_paid_conversion = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // User activation rate\n  const activationPatterns = [\n    /([\\d.]+)%?\\s*(?:activation|activated|complete onboarding)/i,\n    /(?:onboarding|activation).*?([\\d.]+)%/i\n  ];\n  for (const pattern of activationPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.user_activation_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\nconst metrics = extractSaasMetrics(userInput);\n\n// Pricing tier analysis\nlet pricingTiers = null;\nif (userInput.match(/\\b(free|freemium|trial)\\b/i) && userInput.match(/\\b(pro|premium|paid)\\b/i)) {\n  pricingTiers = { model: 'freemium' };\n} else if (userInput.match(/\\b(starter|basic|pro|enterprise)\\b/i)) {\n  pricingTiers = { model: 'tiered' };\n}\n\n// Calculate confidence\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (metricCount >= 3) confidence = 0.9;\nelse if (metricCount >= 2) confidence = 0.8;\nelse if (metricCount >= 1) confidence = 0.7;\n\nreturn {\n  user_input: userInput,\n  monthly_recurring_revenue: metrics.monthly_recurring_revenue || null,\n  annual_recurring_revenue: metrics.annual_recurring_revenue || null,\n  active_subscribers: metrics.active_subscribers || null,\n  new_signups: metrics.new_signups || null,\n  churn_rate: metrics.churn_rate || null,\n  user_activation_rate: metrics.user_activation_rate || null,\n  trial_to_paid_conversion: metrics.trial_to_paid_conversion || null,\n  pricing_tier_distribution: pricingTiers ? JSON.stringify(pricingTiers) : null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        1220
      ],
      "id": "164fe6c3-607d-416d-b604-0ecb75011760",
      "name": "Prepare Business SaaS"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:saas\" (\n  user_id,\n  \"user input\",\n  monthly_recurring_revenue,\n  annual_recurring_revenue,\n  active_subscribers,\n  new_signups,\n  churn_rate,\n  user_activation_rate,\n  feature_adoption_rates,\n  customer_success_score,\n  support_ticket_volume,\n  development_velocity,\n  technical_debt_level,\n  uptime_percentage,\n  user_engagement_score,\n  pricing_tier_distribution,\n  trial_to_paid_conversion,\n  expansion_revenue,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.monthly_recurring_revenue !== undefined && $json.monthly_recurring_revenue !== null ? $json.monthly_recurring_revenue : 'NULL' }},\n  {{ $json.annual_recurring_revenue !== undefined && $json.annual_recurring_revenue !== null ? $json.annual_recurring_revenue : 'NULL' }},\n  {{ $json.active_subscribers !== undefined && $json.active_subscribers !== null ? $json.active_subscribers : 'NULL' }},\n  {{ $json.new_signups !== undefined && $json.new_signups !== null ? $json.new_signups : 'NULL' }},\n  {{ $json.churn_rate !== undefined && $json.churn_rate !== null ? $json.churn_rate : 'NULL' }},\n  {{ $json.user_activation_rate !== undefined && $json.user_activation_rate !== null ? $json.user_activation_rate : 'NULL' }},\n  {{ $json.feature_adoption_rates ? \"'\" + $json.feature_adoption_rates.replace(/'/g, \"''\") + \"'::jsonb\" : 'NULL' }},\n  {{ $json.customer_success_score !== undefined && $json.customer_success_score !== null ? $json.customer_success_score : 'NULL' }},\n  {{ $json.support_ticket_volume !== undefined && $json.support_ticket_volume !== null ? $json.support_ticket_volume : 'NULL' }},\n  {{ $json.development_velocity !== undefined && $json.development_velocity !== null ? $json.development_velocity : 'NULL' }},\n  {{ $json.technical_debt_level !== undefined && $json.technical_debt_level !== null ? $json.technical_debt_level : 'NULL' }},\n  {{ $json.uptime_percentage !== undefined && $json.uptime_percentage !== null ? $json.uptime_percentage : 'NULL' }},\n  {{ $json.user_engagement_score !== undefined && $json.user_engagement_score !== null ? $json.user_engagement_score : 'NULL' }},\n  {{ $json.pricing_tier_distribution ? \"'\" + $json.pricing_tier_distribution.replace(/'/g, \"''\") + \"'::jsonb\" : 'NULL' }},\n  {{ $json.trial_to_paid_conversion !== undefined && $json.trial_to_paid_conversion !== null ? $json.trial_to_paid_conversion : 'NULL' }},\n  {{ $json.expansion_revenue !== undefined && $json.expansion_revenue !== null ? $json.expansion_revenue : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        1220
      ],
      "id": "3a337f83-738b-47e2-9bec-b7e871a236c0",
      "name": "Insert Business SaaS",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n// ===== PREPARE BUSINESS CONTENT (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractContentMetrics(text) {\n  const metrics = {};\n  \n  // Engagement rate - \"3.5% engagement\", \"engaging at 2.8%\"\n  const engPatterns = [\n    /([\\d.]+)%?\\s*(?:engagement|engage|engaging)/i,\n    /(?:engagement|engage).*?([\\d.]+)%/i,\n    /([\\d.]+)\\s*percent.*?engag/i\n  ];\n  for (const pattern of engPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.engagement_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Follower count - \"10k followers\", \"2500 subs\", \"5,000 subscribers\"\n  const followerPatterns = [\n    /([\\d,]+k?)\\s*(?:followers|subs|subscribers|following)/i,\n    /(?:have|got).*?([\\d,]+k?).*?(?:followers|subs|subscribers)/i,\n    /([\\d,]+k?)\\s*(?:people|audience)/i\n  ];\n  for (const pattern of followerPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let count = match[1].replace(/,/g, '');\n      if (count.includes('k')) {\n        count = parseFloat(count.replace('k', '')) * 1000;\n      } else {\n        count = parseInt(count);\n      }\n      metrics.follower_count = count;\n      break;\n    }\n  }\n  \n  // Content pieces - \"posted 15 videos\", \"created 8 articles\"\n  const contentPatterns = [\n    /(?:posted|created|made|published).*?(\\d+).*?(?:posts|videos|articles|pieces|content)/i,\n    /(\\d+)\\s*(?:posts|videos|articles|pieces|reels|stories)/i,\n    /(\\d+).*?(?:pieces of content|content pieces)/i\n  ];\n  for (const pattern of contentPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.content_pieces_created = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Reach/Impressions - \"reached 50k\", \"100k impressions\"\n  const reachPatterns = [\n    /(?:reached|reach).*?([\\d,]+k?)/i,\n    /([\\d,]+k?)\\s*(?:impressions|views|reach)/i,\n    /(?:impressions|views).*?([\\d,]+k?)/i\n  ];\n  for (const pattern of reachPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let count = match[1].replace(/,/g, '');\n      if (count.includes('k')) {\n        count = parseFloat(count.replace('k', '')) * 1000;\n      } else {\n        count = parseInt(count);\n      }\n      metrics.reach_impressions = count;\n      break;\n    }\n  }\n  \n  // Click-through rate\n  const ctrPatterns = [\n    /([\\d.]+)%?\\s*(?:ctr|click.*through|click.*rate)/i,\n    /(?:ctr|click.*through).*?([\\d.]+)%/i\n  ];\n  for (const pattern of ctrPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.click_through_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Content type detection\nlet contentType = null;\nif (userInput.match(/\\b(video|youtube|yt|tiktok|reel|reels|shorts)\\b/i)) {\n  contentType = 'video';\n} else if (userInput.match(/\\b(blog|article|post|writing|seo|content marketing)\\b/i)) {\n  contentType = 'blog';\n} else if (userInput.match(/\\b(podcast|audio|spotify|apple podcasts)\\b/i)) {\n  contentType = 'podcast';\n} else if (userInput.match(/\\b(newsletter|email|email marketing|subscribers)\\b/i)) {\n  contentType = 'newsletter';\n} else if (userInput.match(/\\b(course|training|education|tutorial)\\b/i)) {\n  contentType = 'course';\n} else if (userInput.match(/\\b(social|instagram|facebook|twitter|linkedin)\\b/i)) {\n  contentType = 'social';\n}\n\n// Platform detection with abbreviations\nlet platform = null;\nconst platformMap = {\n  'youtube': ['youtube', 'yt'],\n  'instagram': ['instagram', 'ig', 'insta'],\n  'tiktok': ['tiktok', 'tt'],\n  'linkedin': ['linkedin', 'li'],\n  'twitter': ['twitter', 'x'],\n  'facebook': ['facebook', 'fb'],\n  'email': ['email', 'newsletter'],\n  'blog': ['blog', 'website']\n};\n\nfor (const [platform_name, variations] of Object.entries(platformMap)) {\n  for (const variation of variations) {\n    if (userInput.toLowerCase().includes(variation)) {\n      platform = platform_name;\n      break;\n    }\n  }\n  if (platform) break;\n}\n\n// Posting frequency\nlet frequency = null;\nif (userInput.match(/\\b(daily|every day|each day)\\b/i)) {\n  frequency = 'daily';\n} else if (userInput.match(/\\b(weekly|once a week|per week)\\b/i)) {\n  frequency = 'weekly';\n} else if (userInput.match(/\\b(3x week|three times|3 times.*week)\\b/i)) {\n  frequency = '3x_week';\n} else if (userInput.match(/\\b(twice|2x|two times).*week\\b/i)) {\n  frequency = 'bi_weekly';\n} else if (userInput.match(/\\b(monthly|once a month|per month)\\b/i)) {\n  frequency = 'monthly';\n}\n\n// Content production hours\nlet productionHours = null;\nconst hoursMatch = userInput.match(/(\\d+)\\s*(?:hours?|hrs?)\\s*(?:creating|editing|producing|content)/i);\nif (hoursMatch) productionHours = parseFloat(hoursMatch[1]);\n\nconst metrics = extractContentMetrics(userInput);\n\n// Monetization methods\nconst monetizationMethods = [];\nif (userInput.match(/\\b(sponsorship|sponsored|brand deal)\\b/i)) monetizationMethods.push('sponsorships');\nif (userInput.match(/\\b(affiliate|commission)\\b/i)) monetizationMethods.push('affiliate');\nif (userInput.match(/\\b(course|product|sell|selling)\\b/i)) monetizationMethods.push('product_sales');\nif (userInput.match(/\\b(ads|ad revenue|monetization)\\b/i)) monetizationMethods.push('ad_revenue');\n\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (contentType && platform && metricCount >= 2) confidence = 0.9;\nelse if ((contentType && platform) || metricCount >= 2) confidence = 0.8;\nelse if (contentType || platform || metricCount >= 1) confidence = 0.7;\n\nreturn {\n  user_input: userInput,\n  content_type: contentType,\n  platform: platform,\n  posting_frequency: frequency,\n  content_pieces_created: metrics.content_pieces_created || null,\n  engagement_rate: metrics.engagement_rate || null,\n  follower_count: metrics.follower_count || null,\n  reach_impressions: metrics.reach_impressions || null,\n  click_through_rate: metrics.click_through_rate || null,\n  content_production_hours: productionHours,\n  monetization_methods: monetizationMethods.length > 0 ? monetizationMethods : null,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        960
      ],
      "id": "8a7ef9c1-6832-44d7-b65c-38e30b05ed9b",
      "name": "Prepare Business Content"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:content\" (\n  user_id,\n  \"user input\",\n  content_type,\n  platform,\n  posting_frequency,\n  content_pieces_created,\n  engagement_rate,\n  follower_count,\n  reach_impressions,\n  click_through_rate,\n  conversion_to_lead,\n  content_production_hours,\n  batch_creation_efficiency,\n  repurposing_ratio,\n  trending_content_topics,\n  audience_feedback_sentiment,\n  monetization_methods,\n  revenue_per_thousand_views,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.content_type ? \"'\" + $json.content_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.platform ? \"'\" + $json.platform.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.posting_frequency ? \"'\" + $json.posting_frequency.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.content_pieces_created !== undefined && $json.content_pieces_created !== null ? $json.content_pieces_created : 'NULL' }},\n  {{ $json.engagement_rate !== undefined && $json.engagement_rate !== null ? $json.engagement_rate : 'NULL' }},\n  {{ $json.follower_count !== undefined && $json.follower_count !== null ? $json.follower_count : 'NULL' }},\n  {{ $json.reach_impressions !== undefined && $json.reach_impressions !== null ? $json.reach_impressions : 'NULL' }},\n  {{ $json.click_through_rate !== undefined && $json.click_through_rate !== null ? $json.click_through_rate : 'NULL' }},\n  {{ $json.conversion_to_lead !== undefined && $json.conversion_to_lead !== null ? $json.conversion_to_lead : 'NULL' }},\n  {{ $json.content_production_hours !== undefined && $json.content_production_hours !== null ? $json.content_production_hours : 'NULL' }},\n  {{ $json.batch_creation_efficiency !== undefined && $json.batch_creation_efficiency !== null ? $json.batch_creation_efficiency : 'NULL' }},\n  {{ $json.repurposing_ratio !== undefined && $json.repurposing_ratio !== null ? $json.repurposing_ratio : 'NULL' }},\n  {{ $json.trending_content_topics ? \"ARRAY[\" + $json.trending_content_topics.map(topic => \"'\" + topic.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.audience_feedback_sentiment ? \"'\" + $json.audience_feedback_sentiment.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.monetization_methods ? \"ARRAY[\" + $json.monetization_methods.map(method => \"'\" + method.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.revenue_per_thousand_views !== undefined && $json.revenue_per_thousand_views !== null ? $json.revenue_per_thousand_views : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        960
      ],
      "id": "5fbd9f29-3762-4740-808c-770cf6d21c28",
      "name": "Insert Business Content",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n// ===== PREPARE BUSINESS AGENCY (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractAgencyMetrics(text) {\n  const metrics = {};\n  \n  // Client count - \"have 8 clients\", \"working with 12 clients\"\n  const clientPatterns = [\n    /(?:have|got|working with|managing).*?(\\d+).*?clients?/i,\n    /(\\d+)\\s*(?:active\\s*)?clients?/i,\n    /(\\d+)\\s*(?:customers|accounts)/i\n  ];\n  for (const pattern of clientPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.client_count = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Active projects\n  const projectPatterns = [\n    /(\\d+)\\s*(?:active\\s*)?projects?/i,\n    /(?:working on|managing).*?(\\d+).*?projects?/i,\n    /(\\d+)\\s*(?:ongoing|current).*?projects?/i\n  ];\n  for (const pattern of projectPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.active_projects = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Average project value\n  const valuePatterns = [\n    /(?:projects average|avg project|typical project).*?\\$?([\\d,]+(?:\\.\\d+)?k?)/i,\n    /\\$?([\\d,]+(?:\\.\\d+)?k?).*?(?:per project|each project|project value)/i,\n    /(?:charging|billing).*?\\$?([\\d,]+(?:\\.\\d+)?k?)/i\n  ];\n  for (const pattern of valuePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.average_project_value = parseMoneyValue(match[1]);\n      break;\n    }\n  }\n  \n  // Client retention rate\n  const retentionPatterns = [\n    /([\\d.]+)%?\\s*(?:retention|stay|retain)/i,\n    /(?:retain|keeping).*?([\\d.]+)%.*?clients/i,\n    /([\\d.]+)%.*?clients.*?(?:stay|remain)/i\n  ];\n  for (const pattern of retentionPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.client_retention_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Referral rate\n  const referralPatterns = [\n    /([\\d.]+)%?\\s*(?:referral|referred|referrals)/i,\n    /(?:referral|word of mouth).*?([\\d.]+)%/i\n  ];\n  for (const pattern of referralPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.referral_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Service type detection\nlet serviceType = null;\nif (userInput.match(/\\b(marketing|seo|ppc|ads|social media|content marketing|digital marketing)\\b/i)) {\n  serviceType = 'marketing';\n} else if (userInput.match(/\\b(design|ui|ux|graphic|branding|logo|creative)\\b/i)) {\n  serviceType = 'design';\n} else if (userInput.match(/\\b(development|dev|coding|website|web dev|app dev|software)\\b/i)) {\n  serviceType = 'development';\n} else if (userInput.match(/\\b(consulting|strategy|advisory|business consulting)\\b/i)) {\n  serviceType = 'consulting';\n} else if (userInput.match(/\\b(management|project management|account management)\\b/i)) {\n  serviceType = 'management';\n} else if (userInput.match(/\\b(creative|video|photography|content creation)\\b/i)) {\n  serviceType = 'creative';\n}\n\n// Scope creep detection (1-10 scale)\nlet scopeCreep = 5; // default medium\nif (userInput.match(/\\b(scope creep|always adding|never ends|keeps expanding|endless revisions)\\b/i)) {\n  scopeCreep = 8;\n} else if (userInput.match(/\\b(clear boundaries|good scope|well defined|no scope issues)\\b/i)) {\n  scopeCreep = 2;\n} else if (userInput.match(/\\b(some scope|occasional|minor scope)\\b/i)) {\n  scopeCreep = 4;\n} else if (userInput.match(/\\b(major scope|big scope|significant scope)\\b/i)) {\n  scopeCreep = 7;\n}\n\n// Payment terms\nlet paymentTerms = null;\nconst paymentMatch = userInput.match(/(?:net\\s*)?(\\d+)(?:\\s*days?)?/i);\nif (paymentMatch) paymentTerms = parseInt(paymentMatch[1]);\n\n// Pricing model detection\nlet pricingModel = null;\nif (userInput.match(/\\b(hourly|per hour|hour|hrs)\\b/i)) {\n  pricingModel = 'hourly';\n} else if (userInput.match(/\\b(project|fixed|flat fee)\\b/i)) {\n  pricingModel = 'project';\n} else if (userInput.match(/\\b(retainer|monthly|recurring)\\b/i)) {\n  pricingModel = 'retainer';\n} else if (userInput.match(/\\b(performance|results|commission)\\b/i)) {\n  pricingModel = 'performance';\n}\n\n// Profit margin\nlet profitMargin = null;\nconst marginMatch = userInput.match(/([\\d.]+)%?\\s*(?:profit|margin|markup)/i);\nif (marginMatch) profitMargin = parseFloat(marginMatch[1]);\n\nconst metrics = extractAgencyMetrics(userInput);\n\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (serviceType && metricCount >= 2) confidence = 0.9;\nelse if (serviceType || metricCount >= 2) confidence = 0.8;\nelse if (metricCount >= 1) confidence = 0.7;\n\nreturn {\n  user_input: userInput,\n  service_type: serviceType,\n  client_count: metrics.client_count || null,\n  active_projects: metrics.active_projects || null,\n  average_project_value: metrics.average_project_value || null,\n  client_retention_rate: metrics.client_retention_rate || null,\n  referral_rate: metrics.referral_rate || null,\n  scope_creep_frequency: scopeCreep,\n  payment_terms_days: paymentTerms,\n  pricing_model: pricingModel,\n  profit_margin_percentage: profitMargin,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        700
      ],
      "id": "7bae5276-f942-4743-aa0d-efc85eb4e30e",
      "name": "Prepare Business Agency"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:agency\" (\n  user_id,\n  \"user input\",\n  service_type,\n  client_count,\n  active_projects,\n  average_project_value,\n  project_completion_rate,\n  client_retention_rate,\n  referral_rate,\n  capacity_utilization,\n  profit_margin_percentage,\n  payment_terms_days,\n  outstanding_invoices_amount,\n  scope_creep_frequency,\n  client_satisfaction_score,\n  team_productivity_score,\n  subcontractor_percentage,\n  niche_specialization,\n  pricing_model,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.service_type ? \"'\" + $json.service_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.client_count !== undefined && $json.client_count !== null ? $json.client_count : 'NULL' }},\n  {{ $json.active_projects !== undefined && $json.active_projects !== null ? $json.active_projects : 'NULL' }},\n  {{ $json.average_project_value !== undefined && $json.average_project_value !== null ? $json.average_project_value : 'NULL' }},\n  {{ $json.project_completion_rate !== undefined && $json.project_completion_rate !== null ? $json.project_completion_rate : 'NULL' }},\n  {{ $json.client_retention_rate !== undefined && $json.client_retention_rate !== null ? $json.client_retention_rate : 'NULL' }},\n  {{ $json.referral_rate !== undefined && $json.referral_rate !== null ? $json.referral_rate : 'NULL' }},\n  {{ $json.capacity_utilization !== undefined && $json.capacity_utilization !== null ? $json.capacity_utilization : 'NULL' }},\n  {{ $json.profit_margin_percentage !== undefined && $json.profit_margin_percentage !== null ? $json.profit_margin_percentage : 'NULL' }},\n  {{ $json.payment_terms_days !== undefined && $json.payment_terms_days !== null ? $json.payment_terms_days : 'NULL' }},\n  {{ $json.outstanding_invoices_amount !== undefined && $json.outstanding_invoices_amount !== null ? $json.outstanding_invoices_amount : 'NULL' }},\n  {{ $json.scope_creep_frequency !== undefined && $json.scope_creep_frequency !== null ? $json.scope_creep_frequency : 'NULL' }},\n  {{ $json.client_satisfaction_score !== undefined && $json.client_satisfaction_score !== null ? $json.client_satisfaction_score : 'NULL' }},\n  {{ $json.team_productivity_score !== undefined && $json.team_productivity_score !== null ? $json.team_productivity_score : 'NULL' }},\n  {{ $json.subcontractor_percentage !== undefined && $json.subcontractor_percentage !== null ? $json.subcontractor_percentage : 'NULL' }},\n  {{ $json.niche_specialization ? \"'\" + $json.niche_specialization.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.pricing_model ? \"'\" + $json.pricing_model.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        700
      ],
      "id": "cf10cb6d-051f-4ee1-9386-7c03aab4d5a7",
      "name": "Insert Business Agency",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n// ===== PREPARE BUSINESS OPERATIONS (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractOperationsMetrics(text) {\n  const metrics = {};\n  \n  // Error rate\n  const errorPatterns = [\n    /([\\d.]+)%?\\s*(?:error|mistakes|wrong|failed)/i,\n    /(?:error|mistake).*?([\\d.]+)%/i,\n    /([\\d.]+)\\s*(?:out of|in)\\s*(\\d+).*?(?:error|wrong)/i\n  ];\n  for (const pattern of errorPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      if (match[3]) {\n        // \"3 out of 100\" format\n        metrics.error_rate = (parseFloat(match[1]) / parseFloat(match[2])) * 100;\n      } else {\n        metrics.error_rate = parseFloat(match[1]);\n      }\n      break;\n    }\n  }\n  \n  // Response time\n  const responsePatterns = [\n    /([\\d.]+)\\s*(?:hours?|hrs?|minutes?|mins?)\\s*(?:response|reply|respond)/i,\n    /(?:response|reply).*?([\\d.]+)\\s*(?:hours?|hrs?|minutes?|mins?)/i,\n    /(?:within|under|less than)\\s*([\\d.]+)\\s*(?:hours?|hrs?)/i\n  ];\n  for (const pattern of responsePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let time = parseFloat(match[1]);\n      if (text.includes('minute') || text.includes('min')) {\n        time = time / 60; // Convert to hours\n      }\n      metrics.customer_service_response_time_hours = time;\n      break;\n    }\n  }\n  \n  // System integrations\n  const integrationPatterns = [\n    /(\\d+)\\s*(?:integrations|tools|systems|connected|apps)/i,\n    /(?:using|have|got).*?(\\d+).*?(?:tools|systems|integrations)/i,\n    /(?:connected|integrated).*?(\\d+)/i\n  ];\n  for (const pattern of integrationPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.system_integrations = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Automation level detection (1-10 scale)\nlet automationLevel = 5; // default medium\nif (userInput.match(/\\b(fully automated|completely automated|100% automated)\\b/i)) {\n  automationLevel = 9;\n} else if (userInput.match(/\\b(mostly automated|highly automated|90%|80%)\\b/i)) {\n  automationLevel = 7;\n} else if (userInput.match(/\\b(some automation|partially automated|50%)\\b/i)) {\n  automationLevel = 5;\n} else if (userInput.match(/\\b(little automation|barely automated|20%|30%)\\b/i)) {\n  automationLevel = 3;\n} else if (userInput.match(/\\b(manual|no automation|all manual|0%)\\b/i)) {\n  automationLevel = 1;\n}\n\n// Process documentation completeness (1-10 scale)\nlet processDoc = 5; // default medium\nif (userInput.match(/\\b(well documented|fully documented|everything documented|complete docs)\\b/i)) {\n  processDoc = 9;\n} else if (userInput.match(/\\b(mostly documented|good documentation)\\b/i)) {\n  processDoc = 7;\n} else if (userInput.match(/\\b(some documentation|partially documented)\\b/i)) {\n  processDoc = 5;\n} else if (userInput.match(/\\b(little documentation|poor docs)\\b/i)) {\n  processDoc = 3;\n} else if (userInput.match(/\\b(no documentation|not documented|all in my head|zero docs)\\b/i)) {\n  processDoc = 1;\n}\n\n// Outsourced functions detection\nconst outsourced = [];\nif (userInput.match(/\\b(?:outsourced|hired|delegated).*?accounting\\b/i) || userInput.match(/\\baccountant\\b/i)) {\n  outsourced.push('accounting');\n}\nif (userInput.match(/\\b(?:outsourced|hired|delegated).*?(?:support|customer service)\\b/i) || userInput.match(/\\bva.*support\\b/i)) {\n  outsourced.push('customer_service');\n}\nif (userInput.match(/\\b(?:outsourced|hired|delegated).*?fulfillment\\b/i) || userInput.match(/\\b3pl\\b/i)) {\n  outsourced.push('fulfillment');\n}\nif (userInput.match(/\\b(?:outsourced|hired|delegated).*?marketing\\b/i) || userInput.match(/\\bmarketing agency\\b/i)) {\n  outsourced.push('marketing');\n}\n\n// Backup systems\nlet backupSystems = null;\nif (userInput.match(/\\b(backup|backups|disaster recovery|redundancy)\\b/i)) {\n  if (userInput.match(/\\b(no backup|no backups|not backed up)\\b/i)) {\n    backupSystems = false;\n  } else {\n    backupSystems = true;\n  }\n}\n\n// Time spent on admin\nlet adminTime = null;\nconst adminMatch = userInput.match(/(\\d+)\\s*(?:hours?|hrs?)\\s*(?:admin|administrative|paperwork)/i);\nif (adminMatch) adminTime = parseFloat(adminMatch[1]);\n\nconst metrics = extractOperationsMetrics(userInput);\n\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (automationLevel !== 5 && processDoc !== 5 && metricCount >= 1) confidence = 0.9;\nelse if ((automationLevel !== 5 || processDoc !== 5) || metricCount >= 1) confidence = 0.8;\nelse if (outsourced.length > 0) confidence = 0.7;\n\nreturn {\n  user_input: userInput,\n  automation_level: automationLevel,\n  system_integrations: metrics.system_integrations || null,\n  process_documentation_completeness: processDoc,\n  error_rate: metrics.error_rate || null,\n  customer_service_response_time_hours: metrics.customer_service_response_time_hours || null,\n  backup_systems_in_place: backupSystems,\n  outsourced_functions: outsourced.length > 0 ? outsourced : null,\n  time_spent_on_admin_hours: adminTime,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        440
      ],
      "id": "7c9838a0-a6cc-448a-ba2f-dcf156d355f0",
      "name": "Prepare Business Operations"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:operations\" (\n  user_id,\n  \"user input\",\n  automation_level,\n  system_integrations,\n  manual_processes_count,\n  process_documentation_completeness,\n  error_rate,\n  customer_service_response_time_hours,\n  order_fulfillment_accuracy,\n  inventory_management_system,\n  financial_tracking_system,\n  backup_systems_in_place,\n  security_measures_score,\n  scalability_bottlenecks,\n  outsourced_functions,\n  time_spent_on_admin_hours,\n  system_downtime_hours,\n  data_quality_score,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.automation_level !== undefined && $json.automation_level !== null ? $json.automation_level : 'NULL' }},\n  {{ $json.system_integrations !== undefined && $json.system_integrations !== null ? $json.system_integrations : 'NULL' }},\n  {{ $json.manual_processes_count !== undefined && $json.manual_processes_count !== null ? $json.manual_processes_count : 'NULL' }},\n  {{ $json.process_documentation_completeness !== undefined && $json.process_documentation_completeness !== null ? $json.process_documentation_completeness : 'NULL' }},\n  {{ $json.error_rate !== undefined && $json.error_rate !== null ? $json.error_rate : 'NULL' }},\n  {{ $json.customer_service_response_time_hours !== undefined && $json.customer_service_response_time_hours !== null ? $json.customer_service_response_time_hours : 'NULL' }},\n  {{ $json.order_fulfillment_accuracy !== undefined && $json.order_fulfillment_accuracy !== null ? $json.order_fulfillment_accuracy : 'NULL' }},\n  {{ $json.inventory_management_system ? \"'\" + $json.inventory_management_system.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.financial_tracking_system ? \"'\" + $json.financial_tracking_system.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.backup_systems_in_place !== undefined && $json.backup_systems_in_place !== null ? $json.backup_systems_in_place : 'NULL' }},\n  {{ $json.security_measures_score !== undefined && $json.security_measures_score !== null ? $json.security_measures_score : 'NULL' }},\n  {{ $json.scalability_bottlenecks ? \"ARRAY[\" + $json.scalability_bottlenecks.map(bottleneck => \"'\" + bottleneck.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.outsourced_functions ? \"ARRAY[\" + $json.outsourced_functions.map(func => \"'\" + func.replace(/'/g, \"''\") + \"'\").join(', ') + \"]\" : 'NULL' }},\n  {{ $json.time_spent_on_admin_hours !== undefined && $json.time_spent_on_admin_hours !== null ? $json.time_spent_on_admin_hours : 'NULL' }},\n  {{ $json.system_downtime_hours !== undefined && $json.system_downtime_hours !== null ? $json.system_downtime_hours : 'NULL' }},\n  {{ $json.data_quality_score !== undefined && $json.data_quality_score !== null ? $json.data_quality_score : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        440
      ],
      "id": "614a298a-1509-44cb-8832-db3d3b13965b",
      "name": "Insert Business Operations",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}\n\n// MONEY VALUE PARSER\nfunction parseMoneyValue(value) {\n  if (!value) return null;\n  \n  // Remove common currency symbols and formatting\n  let cleanValue = value.toString().replace(/[$,£€¥]/g, '');\n  \n  // Handle 'k' notation (thousands)\n  if (cleanValue.toLowerCase().includes('k')) {\n    cleanValue = cleanValue.toLowerCase().replace('k', '');\n    return parseFloat(cleanValue) * 1000;\n  }\n  \n  // Handle 'm' notation (millions)\n  if (cleanValue.toLowerCase().includes('m')) {\n    cleanValue = cleanValue.toLowerCase().replace('m', '');\n    return parseFloat(cleanValue) * 1000000;\n  }\n  \n  return parseFloat(cleanValue) || null;\n}\n\n// ===== PREPARE BUSINESS PRODUCT (after shared helpers) =====\nconst data = $json.data;\nconst userInput = data.user_input || '';\nconst emotions = extractDeepEmotionalSignals(userInput);\n\nfunction extractProductMetrics(text) {\n  const metrics = {};\n  \n  // User adoption rate - \"85% adoption\", \"70% of users\", \"adoption rate 60%\"\n  const adoptionPatterns = [\n    /([0-9.]+)%?\\s*(?:adoption|using|active|engaged)/i,\n    /(?:adoption|using).*?([0-9.]+)%/i,\n    /([0-9.]+)%.*?(?:users|customers).*?(?:using|active)/i,\n    /([0-9.]+)\\s*percent.*?adopt/i\n  ];\n  for (const pattern of adoptionPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.user_adoption_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // Feature usage - \"feature used 45%\", \"60% use the feature\"\n  const featurePatterns = [\n    /(?:feature|function).*?([0-9.]+)%/i,\n    /([0-9.]+)%.*?(?:feature|function|use)/i,\n    /([0-9.]+)%.*?(?:engagement|interact)/i\n  ];\n  for (const pattern of featurePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.feature_usage_rate = parseFloat(match[1]);\n      break;\n    }\n  }\n  \n  // User feedback score - \"4.5 rating\", \"8/10\", \"3.2 stars\", \"85% satisfaction\"\n  const feedbackPatterns = [\n    /([0-9.]+)(?:\\/10|\\/5|\\s*stars?|\\s*rating)/i,\n    /(?:rating|score|satisfaction).*?([0-9.]+)(?:\\/10|\\/5|%)?/i,\n    /([0-9.]+)%?\\s*(?:satisfaction|happy|satisfied)/i,\n    /([0-9.]+)\\s*(?:out of|\\/)\\s*([0-9]+)/i\n  ];\n  for (const pattern of feedbackPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let score = parseFloat(match[1]);\n      // Normalize to 0-10 scale\n      if (match[2]) {\n        const outOf = parseFloat(match[2]);\n        score = (score / outOf) * 10;\n      } else if (text.includes('%')) {\n        score = score / 10; // Convert percentage to 0-10\n      } else if (text.includes('star')) {\n        score = (score / 5) * 10; // Convert 5-star to 0-10\n      }\n      metrics.user_feedback_score = Math.min(score, 10);\n      break;\n    }\n  }\n  \n  // Development time - \"6 months\", \"took 3 weeks\", \"built in 2 years\"\n  const devTimePatterns = [\n    /(?:took|built in|developed in).*?([0-9.]+)\\s*(weeks?|months?|years?|days?)/i,\n    /([0-9.]+)\\s*(weeks?|months?|years?|days?).*?(?:development|build|create)/i,\n    /(?:development|building).*?([0-9.]+)\\s*(weeks?|months?|years?)/i\n  ];\n  for (const pattern of devTimePatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      let weeks = parseFloat(match[1]);\n      const unit = match[2].toLowerCase();\n      \n      if (unit.startsWith('day')) weeks = weeks / 7;\n      else if (unit.startsWith('month')) weeks = weeks * 4.33;\n      else if (unit.startsWith('year')) weeks = weeks * 52;\n      \n      metrics.development_time_weeks = Math.round(weeks);\n      break;\n    }\n  }\n  \n  // Team size - \"team of 5\", \"3 developers\", \"8 people\"\n  const teamPatterns = [\n    /(?:team of|team size).*?([0-9]+)/i,\n    /([0-9]+)\\s*(?:developers?|engineers?|people|team members?)/i,\n    /(?:have|got).*?([0-9]+).*?(?:developers?|team|people)/i\n  ];\n  for (const pattern of teamPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.team_size = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  // Bug count/Technical debt - \"50 bugs\", \"technical debt\", \"legacy code\"\n  const bugPatterns = [\n    /([0-9]+)\\s*(?:bugs?|issues?|problems?)/i,\n    /(?:bugs?|issues?).*?([0-9]+)/i\n  ];\n  for (const pattern of bugPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      metrics.bug_count = parseInt(match[1]);\n      break;\n    }\n  }\n  \n  return metrics;\n}\n\n// Product development stage detection\nlet developmentStage = null;\nif (userInput.match(/\\b(idea|concept|planning|just started)/i)) {\n  developmentStage = 'idea';\n} else if (userInput.match(/\\b(prototype|prototyping|mockup|wireframe)/i)) {\n  developmentStage = 'prototype';\n} else if (userInput.match(/\\b(mvp|minimum viable|basic version|alpha)/i)) {\n  developmentStage = 'mvp';\n} else if (userInput.match(/\\b(beta|testing|pre-launch)/i)) {\n  developmentStage = 'beta';\n} else if (userInput.match(/\\b(launched|live|production|released)/i)) {\n  developmentStage = 'launched';\n} else if (userInput.match(/\\b(scaling|growing|mature|established)/i)) {\n  developmentStage = 'scaling';\n}\n\n// Product type detection\nlet productType = null;\nif (userInput.match(/\\b(mobile app|app|ios|android|smartphone)/i)) {\n  productType = 'mobile_app';\n} else if (userInput.match(/\\b(web app|website|webapp|browser|online)/i)) {\n  productType = 'web_app';\n} else if (userInput.match(/\\b(saas|software|platform|tool)/i)) {\n  productType = 'saas';\n} else if (userInput.match(/\\b(api|integration|service|backend)/i)) {\n  productType = 'api';\n} else if (userInput.match(/\\b(physical product|hardware|device|gadget)/i)) {\n  productType = 'physical';\n} else if (userInput.match(/\\b(course|education|training|learning)/i)) {\n  productType = 'educational';\n} else if (userInput.match(/\\b(game|gaming|entertainment)/i)) {\n  productType = 'game';\n}\n\n// Technical debt level (1-10 scale)\nlet techDebtLevel = 5; // default medium\nif (userInput.match(/\\b(clean code|well architected|no debt|maintainable|well structured)/i)) {\n  techDebtLevel = 2;\n} else if (userInput.match(/\\b(some debt|minor issues|okay code)/i)) {\n  techDebtLevel = 4;\n} else if (userInput.match(/\\b(technical debt|legacy|messy|refactor|rewrite)/i)) {\n  techDebtLevel = 7;\n} else if (userInput.match(/\\b(major debt|nightmare|broken|spaghetti|unmaintainable)/i)) {\n  techDebtLevel = 9;\n}\n\n// Product-market fit indicators (1-10 scale)\nlet productMarketFit = 5; // default medium\nif (userInput.match(/\\b(perfect fit|great fit|love it|can't live without|product market fit)/i)) {\n  productMarketFit = 9;\n} else if (userInput.match(/\\b(good fit|works well|users love|positive feedback)/i)) {\n  productMarketFit = 7;\n} else if (userInput.match(/\\b(some fit|mixed feedback|okay response)/i)) {\n  productMarketFit = 5;\n} else if (userInput.match(/\\b(poor fit|struggling|not working|users leaving)/i)) {\n  productMarketFit = 3;\n} else if (userInput.match(/\\b(no fit|complete miss|wrong market|pivot)/i)) {\n  productMarketFit = 1;\n}\n\n// User testing frequency\nlet userTestingFreq = null;\nif (userInput.match(/\\b(daily|every day|constantly)/i)) {\n  userTestingFreq = 'daily';\n} else if (userInput.match(/\\b(weekly|every week|once a week)/i)) {\n  userTestingFreq = 'weekly';\n} else if (userInput.match(/\\b(monthly|every month|once a month)/i)) {\n  userTestingFreq = 'monthly';\n} else if (userInput.match(/\\b(quarterly|every quarter)/i)) {\n  userTestingFreq = 'quarterly';\n} else if (userInput.match(/\\b(rarely|seldom|occasionally)/i)) {\n  userTestingFreq = 'rarely';\n} else if (userInput.match(/\\b(never|no testing|don't test)/i)) {\n  userTestingFreq = 'never';\n}\n\n// Launch timeline extraction\nlet targetLaunchDate = null;\nconst dateTime = extractDateTime(userInput);\nif (dateTime.date) {\n  targetLaunchDate = dateTime.date;\n} else {\n  // Look for launch timeline patterns\n  const launchMatch = userInput.match(/(?:launch|release|go live).*?(\\d+)\\s*(weeks?|months?|days?)/i);\n  if (launchMatch) {\n    const now = new Date();\n    let days = parseInt(launchMatch[1]);\n    const unit = launchMatch[2].toLowerCase();\n    \n    if (unit.startsWith('week')) days = days * 7;\n    else if (unit.startsWith('month')) days = days * 30;\n    \n    const launchDate = new Date(now.getTime() + (days * 24 * 60 * 60 * 1000));\n    targetLaunchDate = launchDate.toISOString().split('T')[0];\n  }\n}\n\n// Competition analysis\nlet competitiveAdvantage = null;\nif (userInput.match(/\\b(unique|first|novel|innovative|revolutionary|breakthrough)/i)) {\n  competitiveAdvantage = 'innovation';\n} else if (userInput.match(/\\b(faster|speed|quick|efficient|performance)/i)) {\n  competitiveAdvantage = 'speed';\n} else if (userInput.match(/\\b(cheaper|affordable|low cost|budget)/i)) {\n  competitiveAdvantage = 'cost';\n} else if (userInput.match(/\\b(better|superior|higher quality|premium)/i)) {\n  competitiveAdvantage = 'quality';\n} else if (userInput.match(/\\b(easier|simple|user friendly|intuitive)/i)) {\n  competitiveAdvantage = 'usability';\n}\n\nconst metrics = extractProductMetrics(userInput);\n\n// Calculate confidence based on extracted data\nlet confidence = data.confidence_level || 0.5;\nconst metricCount = Object.keys(metrics).length;\nif (developmentStage && productType && metricCount >= 3) confidence = 0.9;\nelse if ((developmentStage && productType) || metricCount >= 3) confidence = 0.8;\nelse if (developmentStage || productType || metricCount >= 2) confidence = 0.7;\nelse if (metricCount >= 1) confidence = 0.6;\n\nreturn {\n  user_input: userInput,\n  product_type: productType,\n  development_stage: developmentStage,\n  user_adoption_rate: metrics.user_adoption_rate || null,\n  feature_usage_rate: metrics.feature_usage_rate || null,\n  user_feedback_score: metrics.user_feedback_score || null,\n  development_time_weeks: metrics.development_time_weeks || null,\n  team_size: metrics.team_size || null,\n  bug_count: metrics.bug_count || null,\n  technical_debt_level: techDebtLevel,\n  product_market_fit_score: productMarketFit,\n  user_testing_frequency: userTestingFreq,\n  target_launch_date: targetLaunchDate,\n  competitive_advantage: competitiveAdvantage,\n  confidence_level: confidence,\n  emotional_signals: JSON.stringify(emotions)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        180
      ],
      "id": "5bf36435-e5cd-425a-96e6-26c9ed74712b",
      "name": "Prepare Business Product"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:product\" (\n  user_id,\n  \"user input\",\n  product_type,\n  development_stage,\n  feature_requests_backlog,\n  user_feedback_score,\n  development_velocity,\n  technical_debt_level,\n  quality_assurance_score,\n  market_fit_indicators,\n  competitor_analysis_freshness_days,\n  innovation_frequency,\n  feature_adoption_rate,\n  support_burden_score,\n  pricing_optimization_tests,\n  user_onboarding_completion_rate,\n  product_market_fit_score,\n  roadmap_clarity_score,\n  confidence_level,\n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.product_type ? \"'\" + $json.product_type.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.development_stage ? \"'\" + $json.development_stage.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.feature_requests_backlog !== undefined && $json.feature_requests_backlog !== null ? $json.feature_requests_backlog : 'NULL' }},\n  {{ $json.user_feedback_score !== undefined && $json.user_feedback_score !== null ? $json.user_feedback_score : 'NULL' }},\n  {{ $json.development_time_weeks !== undefined && $json.development_time_weeks !== null ? $json.development_time_weeks : 'NULL' }},\n  {{ $json.technical_debt_level !== undefined && $json.technical_debt_level !== null ? $json.technical_debt_level : 'NULL' }},\n  {{ $json.quality_assurance_score !== undefined && $json.quality_assurance_score !== null ? $json.quality_assurance_score : 'NULL' }},\n  {{ $json.competitive_advantage ? \"'{\\\"competitive_advantage\\\": \\\"\" + $json.competitive_advantage.replace(/'/g, \"''\") + \"\\\"}'::jsonb\" : \n     $json.product_market_fit_score ? \"'{\\\"product_market_fit\\\": \" + $json.product_market_fit_score + \"}'::jsonb\" : \"'{}'\" }},\n  {{ $json.competitor_analysis_freshness_days !== undefined && $json.competitor_analysis_freshness_days !== null ? $json.competitor_analysis_freshness_days : 'NULL' }},\n  {{ $json.user_testing_frequency ? \"'\" + $json.user_testing_frequency.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.feature_usage_rate !== undefined && $json.feature_usage_rate !== null ? $json.feature_usage_rate : \n     $json.user_adoption_rate !== undefined && $json.user_adoption_rate !== null ? $json.user_adoption_rate : 'NULL' }},\n  {{ $json.support_burden_score !== undefined && $json.support_burden_score !== null ? $json.support_burden_score : 'NULL' }},\n  {{ $json.pricing_optimization_tests !== undefined && $json.pricing_optimization_tests !== null ? $json.pricing_optimization_tests : 'NULL' }},\n  {{ $json.user_onboarding_completion_rate !== undefined && $json.user_onboarding_completion_rate !== null ? $json.user_onboarding_completion_rate : 'NULL' }},\n  {{ $json.product_market_fit_score !== undefined && $json.product_market_fit_score !== null ? $json.product_market_fit_score : 'NULL' }},\n  {{ $json.roadmap_clarity_score !== undefined && $json.roadmap_clarity_score !== null ? $json.roadmap_clarity_score : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        180
      ],
      "id": "8dbf90b5-5f9b-44e3-82ee-b8e8095bba59",
      "name": "Insert Business Product",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// EMOTIONAL SIGNAL EXTRACTION - PhD LEVEL\nfunction extractDeepEmotionalSignals(text) {\n  const emotions = [];\n  const emotionalIntensity = {};\n  \n  // Linguistic markers\n  const emotionPatterns = {\n    // Anxiety spectrum\n    anxious: {\n      keywords: ['anxious', 'worried', 'nervous', 'uneasy', 'tense', 'on edge', 'restless'],\n      phrases: ['can\\'t stop thinking', 'what if', 'keeps me up', 'racing thoughts'],\n      punctuation: ['...', '??', '!!!'],\n      intensifiers: ['really', 'so', 'very', 'extremely', 'totally']\n    },\n    stressed: {\n      keywords: ['stressed', 'overwhelmed', 'pressure', 'burnt out', 'exhausted', 'drained'],\n      phrases: ['too much', 'can\\'t handle', 'breaking point', 'falling apart'],\n      linguistic: ['shouty caps', 'fragmented sentences', 'repetition']\n    },\n    frustrated: {\n      keywords: ['frustrated', 'annoyed', 'irritated', 'pissed', 'fed up', 'sick of'],\n      phrases: ['why does this', 'always happens', 'never works', 'tired of'],\n      punctuation: ['!', '...', 'CAPS']\n    },\n    sad: {\n      keywords: ['sad', 'depressed', 'down', 'low', 'blue', 'miserable', 'hopeless'],\n      phrases: ['no point', 'given up', 'can\\'t anymore', 'empty'],\n      linguistic: ['past tense dominance', 'negative absolutes']\n    },\n    guilty: {\n      keywords: ['guilty', 'ashamed', 'bad', 'terrible', 'awful', 'selfish'],\n      phrases: ['should have', 'failed to', 'let down', 'my fault'],\n      linguistic: ['self-blame language', 'responsibility markers']\n    },\n    happy: {\n      keywords: ['happy', 'excited', 'thrilled', 'pumped', 'stoked', 'psyched'],\n      phrases: ['can\\'t wait', 'looking forward', 'best day', 'loving'],\n      punctuation: ['!', '🎉', '😊'],\n      linguistic: ['exclamation marks', 'positive superlatives']\n    },\n    proud: {\n      keywords: ['proud', 'accomplished', 'achieved', 'nailed', 'crushed', 'killed it'],\n      phrases: ['finally did', 'managed to', 'succeeded in'],\n      linguistic: ['achievement language', 'completion markers']\n    },\n    confident: {\n      keywords: ['confident', 'sure', 'certain', 'ready', 'prepared', 'capable'],\n      phrases: ['got this', 'bring it on', 'no problem', 'easy'],\n      linguistic: ['future tense', 'assertive language']\n    },\n    overwhelmed: {\n      keywords: ['overwhelmed', 'drowning', 'buried', 'swamped', 'too much'],\n      phrases: ['can\\'t keep up', 'falling behind', 'losing control'],\n      linguistic: ['quantity markers', 'inability expressions']\n    },\n    hopeful: {\n      keywords: ['hopeful', 'optimistic', 'positive', 'encouraged'],\n      phrases: ['things are looking', 'might work out', 'fingers crossed'],\n      linguistic: ['conditional optimism', 'future positive']\n    }\n  };\n  \n  const textLower = text.toLowerCase();\n  \n  // Analyze each emotion category\n  for (const [emotion, markers] of Object.entries(emotionPatterns)) {\n    let score = 0;\n    let intensity = 0;\n    \n    // Check keywords\n    if (markers.keywords) {\n      for (const keyword of markers.keywords) {\n        if (textLower.includes(keyword)) {\n          score += 2;\n          // Check for intensifiers\n          if (markers.intensifiers) {\n            for (const intensifier of markers.intensifiers) {\n              if (textLower.includes(`${intensifier} ${keyword}`)) {\n                intensity += 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Check phrases\n    if (markers.phrases) {\n      for (const phrase of markers.phrases) {\n        if (textLower.includes(phrase)) {\n          score += 3;\n          intensity += 1;\n        }\n      }\n    }\n    \n    // Punctuation analysis\n    if (markers.punctuation) {\n      for (const punct of markers.punctuation) {\n        if (text.includes(punct)) {\n          score += 1;\n          intensity += 0.5;\n        }\n      }\n    }\n    \n    if (score > 0) {\n      emotions.push(emotion);\n      emotionalIntensity[emotion] = Math.min(intensity, 5);\n    }\n  }\n  \n  // Linguistic analysis\n  const linguisticMarkers = {\n    desperation: /\\b(please|need|must|have to|desperate)\\b/gi,\n    uncertainty: /\\b(maybe|perhaps|might|possibly|probably|guess)\\b/gi,\n    negation: /\\b(not|never|no|can't|won't|don't|didn't)\\b/gi,\n    absolutism: /\\b(always|never|everyone|nobody|everything|nothing)\\b/gi,\n    self_criticism: /\\b(I'm|i am)\\s+(stupid|dumb|worthless|failure|loser)/gi\n  };\n  \n  for (const [marker, pattern] of Object.entries(linguisticMarkers)) {\n    const matches = text.match(pattern);\n    if (matches && matches.length > 2) {\n      if (marker === 'desperation') emotions.push('desperate');\n      if (marker === 'uncertainty') emotions.push('uncertain');\n      if (marker === 'self_criticism') emotions.push('self-critical');\n    }\n  }\n  \n  // Analyze sentence structure\n  const sentences = text.split(/[.!?]+/);\n  const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;\n  \n  if (avgSentenceLength < 5 && sentences.length > 2) {\n    emotions.push('fragmented-thinking');\n  }\n  \n  if (text.match(/[A-Z]{3,}/g)) {\n    emotions.push('shouting');\n    if (!emotions.includes('frustrated')) emotions.push('frustrated');\n  }\n  \n  // Time-based emotional markers\n  if (textLower.match(/\\b(again|always|keeps happening|every time)\\b/)) {\n    emotions.push('pattern-frustrated');\n  }\n  \n  if (textLower.match(/\\b(finally|at last|about time)\\b/)) {\n    emotions.push('relief');\n  }\n  \n  return [...new Set(emotions)];\n}\n\n// ADVANCED DATE/TIME EXTRACTION\nfunction extractDateTime(text) {\n  const now = new Date();\n  const results = {\n    date: null,\n    time: null,\n    timestamp: null\n  };\n  \n  // Time patterns\n  const timePatterns = [\n    { regex: /(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const min = parseInt(m[2]);\n      const meridiem = m[3].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:00`;\n    }},\n    { regex: /(\\d{1,2})\\s*(am|pm|AM|PM)/i, handler: (m) => {\n      let hour = parseInt(m[1]);\n      const meridiem = m[2].toLowerCase();\n      if (meridiem === 'pm' && hour < 12) hour += 12;\n      if (meridiem === 'am' && hour === 12) hour = 0;\n      return `${hour.toString().padStart(2, '0')}:00:00`;\n    }},\n    { regex: /(\\d{1,2}):(\\d{2})/i, handler: (m) => {\n      return `${m[1].padStart(2, '0')}:${m[2]}:00`;\n    }}\n  ];\n  \n  for (const pattern of timePatterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      results.time = pattern.handler(match);\n      break;\n    }\n  }\n  \n  // Date extraction with context\n  const dateContext = {\n    'today': () => now,\n    'tomorrow': () => new Date(now.getTime() + 24*60*60*1000),\n    'yesterday': () => new Date(now.getTime() - 24*60*60*1000),\n    'next week': () => new Date(now.getTime() + 7*24*60*60*1000),\n    'last week': () => new Date(now.getTime() - 7*24*60*60*1000),\n    'next month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      return d;\n    },\n    'last month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() - 1);\n      return d;\n    },\n    'end of month': () => {\n      const d = new Date(now);\n      d.setMonth(d.getMonth() + 1);\n      d.setDate(0);\n      return d;\n    },\n    'end of week': () => {\n      const d = new Date(now);\n      const day = d.getDay();\n      const diff = 7 - day;\n      d.setDate(d.getDate() + diff);\n      return d;\n    }\n  };\n  \n  for (const [phrase, dateFunc] of Object.entries(dateContext)) {\n    if (text.toLowerCase().includes(phrase)) {\n      const date = dateFunc();\n      results.date = date.toISOString().split('T')[0];\n      if (results.time) {\n        results.timestamp = `${results.date}T${results.time}`;\n      }\n      break;\n    }\n  }\n  \n  // \"in X days/weeks/months\" pattern\n  const relativePattern = /in\\s+(\\d+)\\s+(days?|weeks?|months?|hours?)/i;\n  const relMatch = text.match(relativePattern);\n  if (relMatch) {\n    const num = parseInt(relMatch[1]);\n    const unit = relMatch[2].toLowerCase();\n    const futureDate = new Date(now);\n    \n    if (unit.startsWith('hour')) {\n      futureDate.setHours(futureDate.getHours() + num);\n    } else if (unit.startsWith('day')) {\n      futureDate.setDate(futureDate.getDate() + num);\n    } else if (unit.startsWith('week')) {\n      futureDate.setDate(futureDate.getDate() + (num * 7));\n    } else if (unit.startsWith('month')) {\n      futureDate.setMonth(futureDate.getMonth() + num);\n    }\n    \n    results.date = futureDate.toISOString().split('T')[0];\n    results.timestamp = futureDate.toISOString();\n  }\n  \n  // Day of week detection\n  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const dayMatch = text.toLowerCase().match(new RegExp(`(next|this|last)\\\\s+(${daysOfWeek.join('|')})`, 'i'));\n  if (dayMatch) {\n    const modifier = dayMatch[1];\n    const targetDay = daysOfWeek.indexOf(dayMatch[2]);\n    const currentDay = now.getDay();\n    let daysToAdd = targetDay - currentDay;\n    \n    if (modifier === 'next') {\n      if (daysToAdd <= 0) daysToAdd += 7;\n    } else if (modifier === 'last') {\n      if (daysToAdd >= 0) daysToAdd -= 7;\n    }\n    \n    const targetDate = new Date(now);\n    targetDate.setDate(targetDate.getDate() + daysToAdd);\n    results.date = targetDate.toISOString().split('T')[0];\n  }\n  \n  return results;\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -80
      ],
      "id": "8c57f793-463e-497d-a141-3b8e1ffd698a",
      "name": "Prepare Business Finance"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO \"business:sales\" (\n  user_id, \n  \"user input\", \n  deal_value, \n  deal_source, \n  sales_channel,\n  time_to_close, \n  deal_stage, \n  rejection_reason, \n  energy_level_during_sale,\n  follow_ups_required, \n  recipient, \n  company_of_recipient, \n  topic,\n  analysis_sentiment, \n  analysis_keywords, \n  analysis_objections, \n  analysis_next_steps, \n  analysis_recommendation, \n  product_service_offered,\n  email_sent,\n  confidence_level, \n  emotional_signals\n)\nVALUES (\n  '{{ $node[\"Async Entry1\"].json.body.userID }}',\n  {{ $json.user_input ? \"'\" + $json.user_input.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.deal_value !== undefined && $json.deal_value !== null ? $json.deal_value : 'NULL' }},\n  {{ $json.deal_source ? \"'\" + $json.deal_source.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.sales_channel ? \"'\" + $json.sales_channel.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.time_to_close !== undefined ? $json.time_to_close : 'NULL' }},\n  {{ $json.deal_stage ? \"'\" + $json.deal_stage.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.rejection_reason ? \"'\" + $json.rejection_reason.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.energy_level_during_sale !== undefined ? $json.energy_level_during_sale : 'NULL' }},\n  {{ $json.follow_ups_required !== undefined ? $json.follow_ups_required : 'NULL' }},\n  {{ $json.recipient ? \"'\" + $json.recipient.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.company_of_recipient ? \"'\" + $json.company_of_recipient.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.topic ? \"'\" + $json.topic.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_sentiment ? \"'\" + $json.analysis_sentiment.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_keywords ? \"'\" + $json.analysis_keywords.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_objections ? \"'\" + $json.analysis_objections.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_next_steps ? \"'\" + $json.analysis_next_steps.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.analysis_recommendation ? \"'\" + $json.analysis_recommendation.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.product_service_offered ? \"'\" + $json.product_service_offered.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.email_sent ? \"'\" + $json.email_sent.replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n  {{ $json.confidence_level || 0.5 }},\n  {{ $json.emotional_signals ? \"'\" + $json.emotional_signals.replace(/'/g, \"''\") + \"'\" : \"'[]'\" }}\n)\nRETURNING *;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1420,
        -80
      ],
      "id": "ac69fd99-4884-436c-a75d-f49b4f0254bd",
      "name": "Insert Business Finance",
      "credentials": {
        "postgres": {
          "id": "AeWxukKxm7dtP7Wc",
          "name": "CelesteOS"
        }
      }
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        1780,
        -120
      ],
      "id": "26181470-a6ca-46a4-85e2-b25f7c453d1e",
      "name": "Merge4"
    },
    {
      "parameters": {
        "jsCode": "// CELESTE7 DETERMINISTIC ROUTER V2 - THE COMPLETE BEAST! 🔥\n\n// ===== PRE-COMPILED REGEX PATTERNS =====\nconst MONEY_PATTERNS = [\n  /\\$?([\\d,]+(?:\\.\\d+)?)\\s*(?:k|thousand)/gi,\n  /\\$?([\\d,]+(?:\\.\\d+)?)\\s*(?:m|million)/gi,\n  /\\$?([\\d,]+(?:\\.\\d+)?)\\s*(?:grand)/gi,\n  /\\$([\\d,]+(?:\\.\\d+)?)/gi,\n  /earned\\s+([\\d,]+)/gi,\n  /made\\s+([\\d,]+)/gi\n];\n\nconst TIME_PATTERNS = {\n  clock: /(\\d{1,2}):?(\\d{2})?\\s*(am|pm)/gi,\n  duration: /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?|minutes?|mins?)/gi,\n  relative: /(today|tomorrow|yesterday|next\\s+\\w+|last\\s+\\w+|this\\s+\\w+)/gi\n};\n\n// ===== TYPO MAP - EXPANDED =====\nconst TYPO_MAP = {\n  // Money/Sales\n  'maed': 'made', 'mde': 'made', 'mad': 'made', 'maid': 'made',\n  'earnded': 'earned', 'earnd': 'earned', 'erned': 'earned', 'earnedd': 'earned',\n  'sld': 'sold', 'soldd': 'sold', 'soled': 'sold', 'selled': 'sold',\n  'closd': 'closed', 'cloesd': 'closed', 'closedd': 'closed',\n  'deel': 'deal', 'dela': 'deal', 'dael': 'deal', 'deels': 'deals',\n  'clietn': 'client', 'cleint': 'client', 'clinet': 'client',\n  'revneue': 'revenue', 'reveneu': 'revenue', 'revenu': 'revenue',\n  'proffit': 'profit', 'profitt': 'profit',\n  \n  // Actions\n  'faild': 'failed', 'failedd': 'failed', 'faled': 'failed', 'failled': 'failed',\n  'mised': 'missed', 'misd': 'missed', 'missd': 'missed', 'missedd': 'missed',\n  'skiped': 'skipped', 'skipd': 'skipped', 'skipedd': 'skipped',\n  'finishd': 'finished', 'finsihed': 'finished', 'finshed': 'finished',\n  'completd': 'completed', 'complted': 'completed', 'compelted': 'completed',\n  'achived': 'achieved', 'acheived': 'achieved', 'achiveed': 'achieved',\n  \n  // Health/Routine\n  'cofee': 'coffee', 'coffe': 'coffee', 'coffie': 'coffee',\n  'tird': 'tired', 'tierd': 'tired', 'tyred': 'tired',\n  'sleeped': 'slept', 'slep': 'slept', 'sleept': 'slept',\n  'stressd': 'stressed', 'stresed': 'stressed', 'stressedd': 'stressed',\n  'routien': 'routine', 'routin': 'routine', 'ruotine': 'routine',\n  'excersize': 'exercise', 'excersise': 'exercise', 'exersize': 'exercise',\n  'wroked': 'worked', 'wokred': 'worked',\n  \n  // Time\n  'tommorrow': 'tomorrow', 'tommorow': 'tomorrow', 'tomorow': 'tomorrow',\n  'yestarday': 'yesterday', 'yesterdy': 'yesterday',\n  \n  // Business\n  'bussiness': 'business', 'buisness': 'business', 'busines': 'business',\n  'meetting': 'meeting', 'meting': 'meeting', 'meating': 'meeting'\n};\n\n// ===== TRIGGER SYSTEM - COMPREHENSIVE =====\nconst TRIGGERS = {\n  'business:sales': ['sold', 'deal', 'client', 'revenue', 'closed', 'invoice', 'contract', 'sale', 'customer', 'payment', 'earned', 'made $', 'profit', 'loss', 'pipeline', 'prospect', 'lead', 'proposal', 'pitch'],\n  'business:advertisments': ['ads', 'advertising', 'campaign', 'facebook ads', 'google ads', 'marketing', 'spend', 'roi', 'clicks', 'impressions', 'ctr', 'cpc', 'conversion', 'targeting', 'creative', 'ad spend'],\n  'business:networking': ['meeting', 'zoom', 'call', 'referral', 'introduction', 'linkedin', 'contact', 'network', 'connection', 'follow up', 'coffee chat', 'reached out', 'connected with'],\n  'business:models': ['business model', 'revenue model', 'subscription', 'marketplace', 'freemium', 'licensing', 'franchise', 'scalability', 'funding', 'bootstrap', 'venture', 'angel', 'series a', 'break even', 'unit economics', 'cltv', 'cac', 'growth rate', 'profit margin'],\n  'business:product': ['product', 'mvp', 'prototype', 'beta', 'launch', 'user feedback', 'feature', 'bug', 'development', 'technical debt', 'product market fit', 'user testing', 'roadmap', 'competitive advantage', 'mobile app', 'web app', 'saas', 'api'],\n  'business:agency': ['agency', 'client work', 'project', 'scope creep', 'retainer', 'hourly rate', 'fixed price', 'project value', 'client retention', 'referral', 'subcontractor', 'capacity', 'utilization', 'outstanding invoice', 'payment terms', 'net 30'],\n  'business:content': ['content', 'blog', 'video', 'podcast', 'youtube', 'instagram', 'tiktok', 'linkedin', 'engagement', 'followers', 'subscribers', 'impressions', 'reach', 'ctr', 'monetization', 'sponsorship', 'affiliate', 'posting frequency', 'content creation'],\n  'business:ecommerce': ['ecommerce', 'shopify', 'amazon', 'online store', 'inventory', 'product listing', 'conversion rate', 'aov', 'cart abandonment', 'return rate', 'fulfillment', 'shipping', 'supplier', 'seasonal', 'traffic source', 'bestseller'],\n  'business:operations': ['operations', 'automation', 'process', 'system integration', 'manual process', 'documentation', 'error rate', 'response time', 'fulfillment accuracy', 'backup system', 'security', 'bottleneck', 'outsourced', 'admin time', 'downtime'],\n  'business:saas': ['saas', 'software', 'mrr', 'arr', 'monthly recurring', 'annual recurring', 'subscribers', 'signups', 'churn', 'activation', 'trial conversion', 'pricing tier', 'uptime', 'support ticket', 'feature adoption', 'expansion revenue'],\n  'health': ['tired', 'sleep', 'slept', 'energy', 'stressed', 'coffee', 'water', 'sick', 'headache', 'exhausted', 'burnt out', 'burnout', 'vitamins', 'meal', 'ate', 'caffeine', 'crash'],\n  'fitness': ['workout', 'gym', 'ran', 'run', 'exercise', 'lifted', 'weights', 'cardio', 'yoga', 'walked', 'steps', 'calories', 'fitness', 'training', 'reps', 'sets', 'miles', 'km'],\n  'routine': ['morning', 'routine', 'wake', 'woke', '5am', '6am', 'habit', 'missed my', 'skipped my', 'completed my', 'evening routine', 'daily', 'meditation', 'journal'],\n  'goals': ['goal', 'target', 'achieve', 'by next', 'want to', 'need to', 'aiming for', 'milestone', '10k months', 'reach', 'hit', 'objective', 'kpi', 'metric'],\n  'emotions': ['feel', 'feeling', 'anxious', 'worried', 'happy', 'sad', 'frustrated', 'angry', 'proud', 'guilty', 'stressed', 'overwhelmed', 'excited', 'depressed', 'scared'],\n  'family': ['wife', 'husband', 'kids', 'children', 'family', 'dinner', 'missed dinner', 'date night', 'quality time', 'relationship', 'partner', 'spouse', 'son', 'daughter'],\n  'leverage': ['automated', 'hired', 'delegated', 'outsourced', 'tool', 'system', 'process', 'scale', 'leverage', 'va', 'virtual assistant', 'software', 'saas', 'investment'],\n  'common_problems': ['procrastinating', 'avoiding', 'stuck', 'blocked', 'same problem', 'keep doing', 'always', 'never', 'pattern', 'recurring', 'again', 'repeat', 'cycle', 'struggling', 'habit', 'can\\'t stop', 'every time', 'constantly', 'repeatedly', 'chronic', 'persistent', 'ongoing', 'continual', 'habitual', 'routine problem', 'same issue', 'same struggle', 'keep falling', 'trap', 'loop', 'downward spiral'],\n  'performance': ['accomplished', 'achieved', 'failed', 'succeeded', 'completed', 'finished', 'productivity', 'got done', 'productive', 'progress', 'milestone', 'breakthrough'],\n  'user_feedback': ['celeste', 'this ai', 'this app', 'helpful', 'not helpful', 'wrong', 'right', 'love it', 'hate it', 'suggestion', 'feedback', 'improvement', 'feature request', 'bug', 'broken', 'wish']\n};\n\n// ===== ACTIVITY MAPS =====\nconst ACTIVITY_MAPS = {\n  fitness: {\n    'run': 'running', 'ran': 'running', 'jog': 'jogging',\n    'walk': 'walking', 'walked': 'walking',\n    'lift': 'weightlifting', 'lifted': 'weightlifting', 'weights': 'weightlifting',\n    'yoga': 'yoga', 'stretch': 'stretching',\n    'bike': 'cycling', 'cycle': 'cycling', 'biked': 'cycling',\n    'swim': 'swimming', 'swam': 'swimming'\n  },\n  routine: {\n    'meditat': 'meditation', 'journal': 'journaling',\n    'shower': 'shower', 'coffee': 'coffee', 'breakfast': 'breakfast',\n    'prayer': 'prayer', 'gratitude': 'gratitude', 'affirmation': 'affirmations',\n    'read': 'reading', 'plan': 'planning', 'review': 'review',\n    'breathwork': 'breathwork', 'cold shower': 'cold shower'\n  }\n};\n\n// ===== CONFIDENCE SCORING 2.0 - LINGUISTIC APPROACH =====\nconst DIRECTNESS_SCORES = {\n  EXPLICIT: 1.0,      // \"I sold 5 deals\"\n  REPORTED: 0.85,     // \"My team sold 5 deals\"  \n  IMPLIED: 0.7,       // \"Finally hit my numbers\"\n  INFERRED: 0.5,      // \"Things are looking up\"\n  AMBIGUOUS: 0.3,     // \"Maybe next time\"\n  CONTRADICTORY: 0.1  // \"Failed but feeling great!\"\n};\n\nconst MODALITY_MODIFIERS = {\n  certain: { 'definitely': 1.0, 'absolutely': 1.0, 'certainly': 0.95, 'obviously': 0.95 },\n  probable: { 'probably': 0.7, 'likely': 0.7, 'should': 0.6, 'usually': 0.65 },\n  possible: { 'might': 0.5, 'maybe': 0.5, 'could': 0.4, 'perhaps': 0.4, 'possibly': 0.45 },\n  doubtful: { 'doubt': 0.3, 'unlikely': 0.3, 'barely': 0.2, 'hardly': 0.25 }\n};\n\nconst TEMPORAL_CONFIDENCE = {\n  'finally': 0.9,    // Strong completion signal\n  'again': 0.8,      // Pattern confirmation\n  'still': 0.7,      // Ongoing state\n  'always': 0.9,     // Strong pattern\n  'never': 0.9,      // Strong negation\n  'sometimes': 0.5,  // Inconsistent pattern\n  'lately': 0.6,     // Recent but not permanent\n  'used to': 0.4     // Past state, may have changed\n};\n\nfunction hasConflictingEmotions(emotions) {\n  const positive = ['happy', 'excited', 'proud', 'motivated'];\n  const negative = ['sad', 'frustrated', 'anxious', 'guilty'];\n  \n  const hasPositive = emotions.some(e => positive.includes(e));\n  const hasNegative = emotions.some(e => negative.includes(e));\n  \n  return hasPositive && hasNegative;\n}\n\nfunction calculateFieldConfidence(text, field, value, extractionType) {\n  let confidence = 0.5; // Start neutral\n  \n  // 1. DIRECTNESS CHECK\n  if (field === 'deal_value' && text.match(/\\$\\d+/)) {\n    confidence = DIRECTNESS_SCORES.EXPLICIT;\n  } else if (field === 'sleep_hours' && text.match(/\\d+\\s*hours?\\s*(?:of\\s*)?sleep/)) {\n    confidence = DIRECTNESS_SCORES.EXPLICIT;\n  } else if (field === 'deal_stage' && text.includes('closed')) {\n    confidence = DIRECTNESS_SCORES.REPORTED;\n  } else if (extractionType === 'emotion_inference') {\n    confidence = DIRECTNESS_SCORES.IMPLIED;\n  } else if (extractionType === 'pattern_match') {\n    confidence = DIRECTNESS_SCORES.INFERRED;\n  }\n  \n  // 2. MODALITY MODIFIERS\n  for (const [certainty, words] of Object.entries(MODALITY_MODIFIERS)) {\n    for (const [word, score] of Object.entries(words)) {\n      if (text.includes(word)) {\n        confidence *= score;\n        break; // Only apply one modifier\n      }\n    }\n  }\n  \n  // 3. TEMPORAL MODIFIERS\n  for (const [word, modifier] of Object.entries(TEMPORAL_CONFIDENCE)) {\n    if (text.includes(word)) {\n      confidence *= modifier;\n      break;\n    }\n  }\n  \n  // 4. NEGATION PENALTY\n  const negationBeforeValue = new RegExp(`(not|never|didn't|won't|can't)\\\\s+\\\\w*\\\\s*${value}`, 'i');\n  if (negationBeforeValue.test(text)) {\n    confidence *= 0.7;\n  }\n  \n  // 5. QUESTION MARKS = UNCERTAINTY\n  if (text.includes('?')) {\n    confidence *= 0.8;\n  }\n  \n  // 6. MULTIPLE NUMBERS = AMBIGUITY\n  const numbers = text.match(/\\d+/g);\n  if (numbers && numbers.length > 2) {\n    confidence *= 0.85;\n  }\n  \n  return Math.max(0.1, Math.min(confidence, 1.0));\n}\n\nfunction calculateRippleConfidence(primaryConfidence, rippleDistance) {\n  const RIPPLE_DECAY = {\n    1: 0.9,  // Direct cause-effect\n    2: 0.7,  // One step removed\n    3: 0.5,  // Two steps removed\n    4: 0.3   // Distant connection\n  };\n  \n  return primaryConfidence * (RIPPLE_DECAY[rippleDistance] || 0.2);\n}\n\n// ===== HELPER FUNCTIONS =====\nfunction cleanTypos(text) {\n  let cleaned = text.toLowerCase();\n  for (const [typo, correct] of Object.entries(TYPO_MAP)) {\n    const regex = new RegExp(`\\\\b${typo}\\\\b`, 'gi');\n    cleaned = cleaned.replace(regex, correct);\n  }\n  return cleaned;\n}\n\nfunction parseMoneyValue(text) {\n  for (const pattern of MONEY_PATTERNS) {\n    const matches = [...text.matchAll(pattern)];\n    if (matches.length > 0) {\n      const match = matches[0];\n      let value = parseFloat(match[1].replace(/,/g, ''));\n      \n      if (match[0].toLowerCase().includes('k') || match[0].toLowerCase().includes('thousand')) {\n        value *= 1000;\n      } else if (match[0].toLowerCase().includes('m') || match[0].toLowerCase().includes('million')) {\n        value *= 1000000;\n      } else if (match[0].toLowerCase().includes('grand')) {\n        value *= 1000;\n      }\n      \n      return value;\n    }\n  }\n  return null;\n}\n\nfunction parseTime(text) {\n  const match = text.match(/(\\d{1,2}):?(\\d{2})?\\s*(am|pm)/i);\n  if (!match) return null;\n  \n  let hour = parseInt(match[1]);\n  const minute = match[2] ? parseInt(match[2]) : 0;\n  const meridiem = match[3].toLowerCase();\n  \n  if (meridiem === 'pm' && hour < 12) hour += 12;\n  if (meridiem === 'am' && hour === 12) hour = 0;\n  \n  return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:00`;\n}\n\nfunction parseDuration(text) {\n  const patterns = [\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)/i, multiplier: 60 },\n    { regex: /(\\d+(?:\\.\\d+)?)\\s*(?:minutes?|mins?)/i, multiplier: 1 },\n    { regex: /(\\d{1,2}):(\\d{2})/, handler: (match) => parseInt(match[1]) * 60 + parseInt(match[2]) }\n  ];\n  \n  for (const pattern of patterns) {\n    const match = text.match(pattern.regex);\n    if (match) {\n      if (pattern.handler) return pattern.handler(match);\n      return Math.round(parseFloat(match[1]) * pattern.multiplier);\n    }\n  }\n  return null;\n}\n\nfunction parseRelativeDate(text) {\n  const now = new Date();\n  const dayMap = {\n    'today': 0, 'tomorrow': 1, 'yesterday': -1\n  };\n  \n  // Simple day references\n  for (const [key, offset] of Object.entries(dayMap)) {\n    if (text.includes(key)) {\n      now.setDate(now.getDate() + offset);\n      return now.toISOString().split('T')[0];\n    }\n  }\n  \n  // \"next X\" patterns\n  const nextMatch = text.match(/next\\s+(\\w+)/i);\n  if (nextMatch) {\n    const unit = nextMatch[1].toLowerCase();\n    if (unit === 'week') now.setDate(now.getDate() + 7);\n    else if (unit === 'month') now.setMonth(now.getMonth() + 1);\n    else if (unit === 'year') now.setFullYear(now.getFullYear() + 1);\n    return now.toISOString().split('T')[0];\n  }\n  \n  // \"in X days/weeks\" patterns\n  const inMatch = text.match(/in\\s+(\\d+)\\s+(days?|weeks?|months?)/i);\n  if (inMatch) {\n    const num = parseInt(inMatch[1]);\n    const unit = inMatch[2].toLowerCase();\n    if (unit.startsWith('day')) now.setDate(now.getDate() + num);\n    else if (unit.startsWith('week')) now.setDate(now.getDate() + (num * 7));\n    else if (unit.startsWith('month')) now.setMonth(now.getMonth() + num);\n    return now.toISOString().split('T')[0];\n  }\n  \n  return null;\n}\n\nfunction extractEmotions(text) {\n  const emotions = [];\n  const emotionMap = {\n    'happy': ['happy', 'excited', 'proud', 'great', 'amazing', 'fantastic'],\n    'sad': ['sad', 'depressed', 'down', 'low', 'miserable'],\n    'anxious': ['anxious', 'worried', 'nervous', 'scared', 'fear'],\n    'frustrated': ['frustrated', 'annoyed', 'pissed', 'angry', 'mad'],\n    'tired': ['tired', 'exhausted', 'drained', 'burnt out', 'fatigue'],\n    'guilty': ['guilty', 'ashamed', 'bad about', 'regret'],\n    'stressed': ['stressed', 'overwhelmed', 'pressure', 'tension'],\n    'motivated': ['motivated', 'determined', 'focused', 'driven'],\n    'accomplished': ['accomplished', 'achieved', 'succeeded', 'completed']\n  };\n  \n  for (const [emotion, keywords] of Object.entries(emotionMap)) {\n    if (keywords.some(keyword => text.includes(keyword))) {\n      emotions.push(emotion);\n    }\n  }\n  \n  return [...new Set(emotions)]; // Remove duplicates\n}\n\nfunction detectTables(text) {\n  const tables = new Set();\n  const cleanedText = cleanTypos(text);\n  \n  // Primary detection\n  for (const [table, keywords] of Object.entries(TRIGGERS)) {\n    if (keywords.some(keyword => cleanedText.includes(keyword))) {\n      tables.add(table);\n    }\n  }\n  \n  // Multi-table patterns\n  if (cleanedText.includes('morning routine') && cleanedText.includes('missed')) {\n    tables.add('routine');\n    tables.add('common_problems');\n  }\n  \n  if (cleanedText.match(/\\$[\\d,]+|earned|made.*\\d+/) && !tables.has('business:sales')) {\n    tables.add('business:sales');\n  }\n  \n  if (cleanedText.includes('tired') && cleanedText.includes('work')) {\n    tables.add('health');\n    tables.add('performance');\n  }\n  \n  if (cleanedText.includes('family') && cleanedText.includes('work')) {\n    tables.add('family');\n    tables.add('common_problems');\n  }\n  \n  return Array.from(tables);\n}\n\n// ===== EXTRACTION FUNCTIONS - ALL 15 TABLES =====\n\nfunction extractBusinessSales(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Deal value\n  const moneyValue = parseMoneyValue(text);\n  if (moneyValue) {\n    data.deal_value = moneyValue;\n    // Calculate confidence based on directness and modifiers\n    data.confidence_level = calculateFieldConfidence(text, 'deal_value', moneyValue, 'explicit');\n  }\n  \n  // Deal count\n  const dealMatch = text.match(/(\\d+)\\s*(?:deals?|clients?|sales?|contracts?)/i);\n  if (dealMatch) {\n    data.deals_count = parseInt(dealMatch[1]);\n    // High confidence if number directly precedes deal word\n    data.confidence_level = calculateFieldConfidence(text, 'deals_count', dealMatch[1], 'explicit');\n  }\n  \n  // Deal stage\n  if (text.includes('closed') || text.includes('sold') || text.includes('won')) {\n    data.deal_stage = 'closed';\n    // Check for modifiers like \"almost closed\" or \"probably closed\"\n    data.confidence_level = calculateFieldConfidence(text, 'deal_stage', 'closed', 'reported');\n  } else if (text.includes('lost') || text.includes('failed')) {\n    data.deal_stage = 'lost';\n    data.confidence_level = calculateFieldConfidence(text, 'deal_stage', 'lost', 'reported');\n  } else if (text.includes('negotiat') || text.includes('discuss')) {\n    data.deal_stage = 'negotiation';\n    data.confidence_level = calculateFieldConfidence(text, 'deal_stage', 'negotiation', 'implied');\n  } else if (text.includes('proposal sent') || text.includes('sent proposal')) {\n    data.deal_stage = 'proposal';\n    data.confidence_level = calculateFieldConfidence(text, 'deal_stage', 'proposal', 'explicit');\n  }\n  \n  // Sales channel\n  const channels = ['email', 'phone', 'linkedin', 'referral', 'website', 'cold call'];\n  for (const channel of channels) {\n    if (text.includes(channel)) {\n      data.sales_channel = channel;\n      break;\n    }\n  }\n  \n  // Time to close\n  const timeMatch = text.match(/(\\d+)\\s*(?:days?|weeks?)\\s*(?:to close|closing)/i);\n  if (timeMatch) {\n    data.time_to_close = parseInt(timeMatch[1]);\n  }\n  \n  // SaaS metrics\n  if (text.includes('mrr') || text.includes('monthly recurring')) {\n    data.revenue_type = 'recurring';\n  } else if (text.includes('one-time') || text.includes('one time')) {\n    data.revenue_type = 'one-time';\n  }\n  \n  // Churn/loss reasons\n  if (text.includes('churn') || text.includes('cancelled')) {\n    data.churn_reason = 'customer cancelled';\n  } else if (text.includes('competitor')) {\n    data.rejection_reason = 'chose competitor';\n  }\n  \n  // Adjust confidence for emotional context\n  if (emotions.includes('excited') && data.deal_stage === 'closed') {\n    data.confidence_level = Math.min(data.confidence_level * 1.1, 1.0);\n  } else if (emotions.includes('disappointed') && data.deal_stage === 'lost') {\n    data.confidence_level = Math.min(data.confidence_level * 1.1, 1.0);\n  } else if (hasConflictingEmotions(emotions)) {\n    data.confidence_level *= 0.85;\n  }\n  \n  return data;\n}\n\nfunction extractBusinessNetworking(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Contact type\n  if (text.includes('zoom') || text.includes('video')) data.contact_type = 'video call';\n  else if (text.includes('call') || text.includes('phone')) data.contact_type = 'phone';\n  else if (text.includes('coffee') || text.includes('lunch')) data.contact_type = 'in-person';\n  else if (text.includes('email')) data.contact_type = 'email';\n  else if (text.includes('linkedin')) data.contact_type = 'linkedin';\n  \n  // Referrals\n  const referralMatch = text.match(/(\\d+)\\s*(?:referrals?|introductions?|connections?)/i);\n  if (referralMatch) {\n    data.referrals_generated = parseInt(referralMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Follow up\n  if (text.includes('follow up') || text.includes('following up') || text.includes('scheduled')) {\n    data.follow_up_scheduled = true;\n  }\n  \n  // Value exchange\n  if (text.includes('helped') || text.includes('provided') || text.includes('gave')) {\n    data.value_provided = 'help given';\n  }\n  \n  return data;\n}\n\nfunction extractBusinessAdvertisements(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Ad spend\n  if (text.includes('spent') || text.includes('spend')) {\n    const spendValue = parseMoneyValue(text);\n    if (spendValue) {\n      data.ad_spend = spendValue;\n      data.confidence_level = 0.9;\n    }\n  }\n  \n  // Platform\n  const platforms = ['facebook', 'google', 'instagram', 'tiktok', 'linkedin', 'youtube'];\n  for (const platform of platforms) {\n    if (text.includes(platform)) {\n      data.platform = platform.charAt(0).toUpperCase() + platform.slice(1);\n      break;\n    }\n  }\n  \n  // Metrics\n  const metricsMap = {\n    'impressions': /(\\d+)\\s*impressions/i,\n    'clicks': /(\\d+)\\s*clicks/i,\n    'conversions': /(\\d+)\\s*conversions/i\n  };\n  \n  for (const [metric, pattern] of Object.entries(metricsMap)) {\n    const match = text.match(pattern);\n    if (match) data[metric] = parseInt(match[1]);\n  }\n  \n  // ROI\n  const roiMatch = text.match(/(\\d+)%?\\s*roi/i);\n  if (roiMatch) {\n    data.roi_percentage = parseFloat(roiMatch[1]);\n  }\n  \n  return data;\n}\n\nfunction extractHealth(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Sleep hours\n  const sleepPatterns = [\n    /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)\\s*(?:of\\s*)?sleep/i,\n    /slept\\s*(?:for\\s*)?(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)/i,\n    /got\\s*(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?)/i\n  ];\n  \n  for (const pattern of sleepPatterns) {\n    const match = text.match(pattern);\n    if (match) {\n      data.sleep_hours = parseFloat(match[1]);\n      data.confidence_level = calculateFieldConfidence(text, 'sleep_hours', match[1], 'explicit');\n      break;\n    }\n  }\n  \n  // Stress level (1-10) with confidence based on intensity markers\n  if (text.includes('overwhelmed') || text.includes('breaking point')) {\n    data.stress_level = 9;\n    data.confidence_level = calculateFieldConfidence(text, 'stress_level', 'high', 'explicit');\n  } else if (text.includes('very stressed') || text.includes('extremely stressed')) {\n    data.stress_level = 8;\n    data.confidence_level = calculateFieldConfidence(text, 'stress_level', 'high', 'reported');\n  } else if (text.includes('stressed') || text.includes('anxious')) {\n    data.stress_level = 7;\n    data.confidence_level = calculateFieldConfidence(text, 'stress_level', 'moderate', 'implied');\n  } else if (text.includes('tense') || text.includes('pressure')) {\n    data.stress_level = 6;\n    data.confidence_level = calculateFieldConfidence(text, 'stress_level', 'moderate', 'inferred');\n  } else if (text.includes('calm') || text.includes('relaxed')) {\n    data.stress_level = 3;\n    data.confidence_level = calculateFieldConfidence(text, 'stress_level', 'low', 'reported');\n  }\n  \n  // Coffee intake\n  const coffeeMatch = text.match(/(\\d+)\\s*(?:cups?\\s*of\\s*)?(?:coffee|espresso|latte|caffeine)/i);\n  if (coffeeMatch) {\n    data.caffeine_intake = parseInt(coffeeMatch[1]);\n    // Higher confidence if \"cups of coffee\" vs just \"3 coffee\"\n    const hasUnit = text.includes('cup') || text.includes('cups');\n    data.confidence_level = calculateFieldConfidence(\n      text, \n      'caffeine_intake', \n      coffeeMatch[1], \n      hasUnit ? 'explicit' : 'implied'\n    );\n  }\n  \n  // Water intake\n  const waterMatch = text.match(/(\\d+(?:\\.\\d+)?)\\s*(?:liters?|litres?|l)\\s*(?:of\\s*)?water/i);\n  if (waterMatch) {\n    data.water_liters = parseFloat(waterMatch[1]);\n    data.confidence_level = calculateFieldConfidence(text, 'water_liters', waterMatch[1], 'explicit');\n  }\n  \n  // Meals\n  const mealKeywords = ['breakfast', 'lunch', 'dinner', 'snack'];\n  let mealCount = 0;\n  let mealConfidence = 1.0;\n  for (const meal of mealKeywords) {\n    if (text.includes(meal)) {\n      mealCount++;\n      // Check for negation \"skipped breakfast\"\n      const skippedPattern = new RegExp(`(skipped|missed|no)\\\\s+${meal}`, 'i');\n      if (skippedPattern.test(text)) {\n        mealCount--;\n        mealConfidence *= 0.8;\n      }\n    }\n  }\n  if (mealCount > 0) {\n    data.meals_count = mealCount;\n    data.confidence_level = calculateFieldConfidence(text, 'meals_count', mealCount, 'reported') * mealConfidence;\n  }\n  \n  // Energy crashes\n  if (text.includes('crash') || text.includes('energy dip') || text.includes('afternoon slump')) {\n    data.energy_crashes = 'afternoon';\n    data.confidence_level = calculateFieldConfidence(text, 'energy_crashes', 'crash', 'explicit');\n  }\n  \n  // Health issues with varying confidence\n  if (text.includes('migraine')) {\n    data.health_issue = 'headache';\n    data.confidence_level = calculateFieldConfidence(text, 'health_issue', 'migraine', 'explicit');\n  } else if (text.includes('headache')) {\n    data.health_issue = 'headache';\n    data.confidence_level = calculateFieldConfidence(text, 'health_issue', 'headache', 'reported');\n  } else if (text.includes('head hurts')) {\n    data.health_issue = 'headache';\n    data.confidence_level = calculateFieldConfidence(text, 'health_issue', 'headache', 'implied');\n  }\n  \n  // Ripple effects from emotions\n  if (emotions.includes('exhausted')) {\n    if (!data.sleep_hours) {\n      data.sleep_quality = 'poor';\n      // This is inferred from emotion, so lower confidence\n      data.confidence_level = calculateRippleConfidence(0.7, 2);\n    }\n  }\n  \n  // Context boosting\n  if (emotions.includes('tired') && data.sleep_hours && data.sleep_hours < 6) {\n    // Emotion confirms the data\n    data.confidence_level = Math.min(data.confidence_level * 1.15, 1.0);\n  }\n  \n  return data;\n}\n\nfunction extractFitness(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Activity type\n  for (const [keyword, activity] of Object.entries(ACTIVITY_MAPS.fitness)) {\n    if (text.includes(keyword)) {\n      data.Activity = activity;\n      data.workout_type = activity;\n      data.confidence_level = 0.8;\n      break;\n    }\n  }\n  \n  // Duration\n  const duration = parseDuration(text);\n  if (duration) {\n    data.duration_minutes = duration;\n  }\n  \n  // Distance/Weight\n  const distanceMatch = text.match(/(\\d+(?:\\.\\d+)?)\\s*(miles?|km|kilometers?)/i);\n  if (distanceMatch) {\n    data['Time/weight'] = parseFloat(distanceMatch[1]);\n    data.MetricType = 'Distance';\n  }\n  \n  const weightMatch = text.match(/(\\d+)\\s*(lbs?|pounds?|kg|kilograms?)/i);\n  if (weightMatch) {\n    data['Time/weight'] = parseFloat(weightMatch[1]);\n    data.MetricType = 'Weight';\n  }\n  \n  // Intensity (1-10)\n  if (text.includes('intense') || text.includes('hard')) data.intensity = 8;\n  else if (text.includes('moderate')) data.intensity = 5;\n  else if (text.includes('easy') || text.includes('light')) data.intensity = 3;\n  \n  // Workout time\n  const workoutTime = parseTime(text);\n  if (workoutTime) data.workout_time = workoutTime;\n  \n  // Missed workout\n  if (text.includes('missed') || text.includes('skipped')) {\n    data.missed_planned_workout = true;\n    if (text.includes('tired')) data.excuse_if_missed = 'too tired';\n    else if (text.includes('busy')) data.excuse_if_missed = 'too busy';\n    else if (text.includes('sore')) data.excuse_if_missed = 'too sore';\n    else if (text.includes('injured') || text.includes('hurt')) data.excuse_if_missed = 'injury';\n    else if (text.includes('sick')) data.excuse_if_missed = 'sick';\n  }\n  \n  // Injury tracking\n  if (text.includes('pulled') || text.includes('strain') || text.includes('injury')) {\n    data.injury_reported = true;\n  }\n  \n  return data;\n}\n\nfunction extractRoutine(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Routine type\n  if (text.includes('morning')) data.routine_type = 'morning';\n  else if (text.includes('evening') || text.includes('night')) data.routine_type = 'evening';\n  else if (text.includes('daily')) data.routine_type = 'daily';\n  \n  // Wake/sleep time\n  const timeMatch = text.match(/(\\d{1,2}):?(\\d{2})?\\s*(am|pm)/i);\n  if (timeMatch) {\n    const time = parseTime(text);\n    if (text.includes('wake') || text.includes('woke') || text.includes('up at')) {\n      data.wake_time = time;\n      data.confidence_level = 0.9;\n    } else if (text.includes('sleep') || text.includes('bed')) {\n      data.sleep_time = time;\n    }\n  }\n  \n  // Activities\n  const activities = [];\n  for (const [keyword, activity] of Object.entries(ACTIVITY_MAPS.routine)) {\n    if (text.includes(keyword)) {\n      activities.push(activity);\n    }\n  }\n  if (activities.length > 0) data.activities = activities;\n  \n  // Completion\n  if (text.includes('missed') || text.includes('skipped') || text.includes(\"didn't\")) {\n    data.completed = false;\n    if (text.includes('tired')) data.missed_reason = 'too tired';\n    else if (text.includes('overslept')) data.missed_reason = 'overslept';\n    else if (text.includes('busy')) data.missed_reason = 'too busy';\n  } else if (text.includes('completed') || text.includes('did my') || text.includes('crushed')) {\n    data.completed = true;\n  }\n  \n  // Duration\n  const duration = parseDuration(text);\n  if (duration) data.duration_minutes = duration;\n  \n  // Streak\n  const streakMatch = text.match(/(\\d+)\\s*days?\\s*(?:streak|in a row|consecutive)/i);\n  if (streakMatch) {\n    data.streak_days = parseInt(streakMatch[1]);\n  }\n  \n  return data;\n}\n\nfunction extractGoals(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Target value\n  const moneyValue = parseMoneyValue(text);\n  if (moneyValue) {\n    data.target_value = moneyValue;\n    data.unit_of_measurement = 'dollars';\n    data.goal_type = 'financial';\n    data.confidence_level = 0.9;\n  }\n  \n  // Multiplier goals\n  const multiplierMatch = text.match(/(\\d+)x\\s/i);\n  if (multiplierMatch) {\n    data.target_value = parseInt(multiplierMatch[1]);\n    data.unit_of_measurement = 'multiplier';\n    data.goal_type = 'growth';\n  }\n  \n  // Percentage goals\n  const percentMatch = text.match(/(\\d+)%/);\n  if (percentMatch) {\n    data.target_value = parseInt(percentMatch[1]);\n    data.unit_of_measurement = 'percentage';\n  }\n  \n  // Goal type detection\n  if (text.includes('revenue') || text.includes('sales') || text.includes('income')) data.goal_type = 'financial';\n  else if (text.includes('weight') || text.includes('fitness') || text.includes('health')) data.goal_type = 'health';\n  else if (text.includes('client') || text.includes('customer')) data.goal_type = 'business';\n  else if (text.includes('habit') || text.includes('routine')) data.goal_type = 'habits';\n  else if (text.includes('product') || text.includes('launch') || text.includes('ship')) data.goal_type = 'product';\n  else if (text.includes('skill') || text.includes('learn')) data.goal_type = 'development';\n  \n  // Deadline\n  const deadline = parseRelativeDate(text);\n  if (deadline) {\n    data.deadline = deadline;\n  }\n  \n  // Priority (1-3)\n  if (emotions.includes('urgent') || emotions.includes('desperate')) data.priority = 1;\n  else if (emotions.includes('motivated') || emotions.includes('determined')) data.priority = 2;\n  else data.priority = 3;\n  \n  return data;\n}\n\nfunction extractEmotionsTable(text, emotions) {\n  const data = {\n    user_input: text,\n    emotions: emotions.join(', '),\n    emotional_signals: emotions,\n    confidence_level: 0.8\n  };\n  \n  // Topic detection\n  if (text.includes('business') || text.includes('work')) data.topic = 'business';\n  else if (text.includes('family') || text.includes('relationship')) data.topic = 'relationships';\n  else if (text.includes('money') || text.includes('financial')) data.topic = 'finances';\n  else if (text.includes('health') || text.includes('fitness')) data.topic = 'health';\n  else data.topic = 'general';\n  \n  // Fears\n  const fears = [];\n  if (text.includes('fail')) fears.push('failure');\n  if (text.includes('reject')) fears.push('rejection');\n  if (text.includes('broke') || text.includes('bankrupt')) fears.push('financial ruin');\n  if (text.includes('alone') || text.includes('lonely')) fears.push('loneliness');\n  if (fears.length > 0) data.fears = fears.join(', ');\n  \n  // Insecurities\n  if (text.includes('not good enough') || text.includes('imposter')) {\n    data.insecurities = 'self-doubt';\n  }\n  \n  return data;\n}\n\nfunction extractFamily(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Interaction type\n  if (text.includes('dinner')) data.interaction_type = 'dinner';\n  else if (text.includes('breakfast')) data.interaction_type = 'breakfast';\n  else if (text.includes('call') || text.includes('phone')) data.interaction_type = 'phone call';\n  else if (text.includes('game') || text.includes('play')) data.interaction_type = 'play time';\n  else if (text.includes('movie') || text.includes('watch')) data.interaction_type = 'watching together';\n  else data.interaction_type = 'quality time';\n  \n  // Duration\n  const duration = parseDuration(text);\n  if (duration) data.duration_minutes = duration;\n  \n  // Relationship\n  if (text.includes('wife') || text.includes('husband')) data.relationship_affected = 'spouse';\n  else if (text.includes('kid') || text.includes('child')) data.relationship_affected = 'children';\n  else if (text.includes('parent')) data.relationship_affected = 'parents';\n  else data.relationship_affected = 'family';\n  \n  // Work interrupted\n  if (text.includes('work') && text.includes('interrupted')) {\n    data.work_interrupted = true;\n  }\n  \n  // Guilt level (1-10)\n  if (text.includes('guilty') || emotions.includes('guilty')) {\n    data.guilt_level = text.includes('very') ? 8 : 6;\n  }\n  \n  // Happiness impact (1-10)\n  if (emotions.includes('happy') || emotions.includes('proud')) {\n    data.happiness_impact = 8;\n  } else if (emotions.includes('guilty') || emotions.includes('sad')) {\n    data.happiness_impact = 3;\n  }\n  \n  // Conflict detection\n  if (text.includes('argument') || text.includes('fight') || text.includes('argued')) {\n    data.conflict_occurred = true;\n    data.happiness_impact = 2;\n  } else if (text.includes('tension') || text.includes('awkward')) {\n    data.conflict_occurred = true;\n    data.happiness_impact = 4;\n  }\n  \n  return data;\n}\n\nfunction extractLeverage(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Leverage type\n  if (text.includes('automat') || text.includes('tool') || text.includes('software')) {\n    data.leverage_type = 'automation';\n  } else if (text.includes('hire') || text.includes('va') || text.includes('assistant')) {\n    data.leverage_type = 'hiring';\n  } else if (text.includes('delegate') || text.includes('outsource')) {\n    data.leverage_type = 'delegation';\n  } else if (text.includes('system') || text.includes('process')) {\n    data.leverage_type = 'systems';\n  }\n  \n  // Time saved\n  const timeMatch = text.match(/saved?\\s*(\\d+)\\s*(?:hours?|hrs?)/i);\n  if (timeMatch) {\n    data.time_saved_hours = parseInt(timeMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Cost\n  const cost = parseMoneyValue(text);\n  if (cost && (text.includes('cost') || text.includes('invest') || text.includes('spent'))) {\n    data.cost_invested = cost;\n  }\n  \n  // ROI/Multiplier\n  const roiMatch = text.match(/(\\d+)x\\s*(?:roi|return|multiplier)/i);\n  if (roiMatch) {\n    data.multiplier_effect = parseInt(roiMatch[1]);\n  }\n  \n  return data;\n}\n\nfunction extractCommonProblems(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.7\n  };\n  \n  // Pattern detection\n  if (text.includes('always') || text.includes('keep doing')) data.Pattern = 'recurring';\n  else if (text.includes('again') || text.includes('same')) data.Pattern = 'repeating';\n  else if (text.includes('never') || text.includes(\"can't\")) data.Pattern = 'persistent block';\n  else if (text.includes('stuck') || text.includes('blocked')) data.Pattern = 'stagnation';\n  else if (text.includes('procrastinat') || text.includes('putting off') || text.includes('delaying')) data.Pattern = 'procrastination';\n  else if (text.includes('avoid') || text.includes('dodging')) data.Pattern = 'avoidance';\n  else if (text.includes('cycle') || text.includes('loop')) data.Pattern = 'cyclical';\n  else if (text.includes('spiral') || text.includes('worse')) data.Pattern = 'downward spiral';\n  else data.Pattern = 'behavioral';\n  \n  // Category\n  const cleanedText = cleanTypos(text);\n  if (cleanedText.includes('sale') || cleanedText.includes('client')) data.Category = 'business:sales';\n  else if (cleanedText.includes('health') || cleanedText.includes('sleep')) data.Category = 'health';\n  else if (cleanedText.includes('family') || cleanedText.includes('relationship')) data.Category = 'family';\n  else if (cleanedText.includes('workout') || cleanedText.includes('gym')) data.Category = 'fitness';\n  else if (cleanedText.includes('routine') || cleanedText.includes('habit')) data.Category = 'routine';\n  else data.Category = 'general';\n  \n  // Problem description\n  data.CommonProblems = text;\n  \n  return data;\n}\n\nfunction extractPerformance(text, emotions) {\n  const data = {\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Success patterns (including typos)\n  const successPattern = /\\b(sold|sld|made|maed|earned|earnd|achieved|achived|hit|reached|reched|completed|complted|finished|finishd|launched|lauched|shipped|shiped|closed|closd|won|gained|gaind)\\b/i;\n  \n  // Failure patterns (including typos)\n  const failurePattern = /\\b(missed|misd|mised|failed|faild|lost|lst|couldn't|couldnt|didn't|didnt|unable|unabl|stuck|stuk|blocked|blockd|struggled|struggld)\\b/i;\n  \n  // Check for money mentions with success words\n  const hasMoneySuccess = (text.match(/\\$[\\d,]+/) || parseMoneyValue(text)) && successPattern.test(text);\n  \n  if (hasMoneySuccess || (successPattern.test(text) && !failurePattern.test(text))) {\n    data.WhatWentWell = text;\n    data.confidence_level = 0.9;\n  } else if (failurePattern.test(text)) {\n    data.WhatBlocked = text;\n    data.confidence_level = 0.9;\n  }\n  \n  // Tomorrow's hurdle\n  if (text.includes('tomorrow') || text.includes('need to') || text.includes('have to')) {\n    data.TomorrowHurdle = text;\n  }\n  \n  // Energy level correlation\n  if (text.includes('energized') || text.includes('pumped')) {\n    data.energy_level = 'high';\n  } else if (text.includes('tired') || text.includes('exhausted')) {\n    data.energy_level = 'low';\n  }\n  \n  return data;\n}\n\nfunction extractUserFeedback(text, emotions, sessionID, previousAIReply) {\n  const data = {\n    user_input: text,\n    sessionID: sessionID,\n    emotional_signals: emotions,\n    confidence_level: 0.8\n  };\n  \n  // AI suggestion responses\n  if (previousAIReply) {\n    data.ai_response = previousAIReply;\n    \n    // Acceptance patterns\n    if (text.match(/\\b(ok|okay|sure|will do|i'll try|good idea|makes sense|got it|thanks|helpful)\\b/i)) {\n      data.suggestion_accepted = true;\n      data.feedback_sentiment = 'positive';\n      data.confidence_level = 0.9;\n    }\n    \n    // Rejection patterns\n    else if (text.match(/\\b(no|won't work|can't|already tried|doesn't help|bad idea|wrong)\\b/i)) {\n      data.suggestion_accepted = false;\n      data.feedback_sentiment = 'negative';\n      data.confidence_level = 0.9;\n    }\n    \n    // Explanation patterns\n    if (text.includes('because') || text.includes('but')) {\n      data.reasoning_provided = text;\n      data.has_context = true;\n    }\n  }\n  \n  // Meta feedback about Celeste7\n  if (text.match(/\\b(celeste|this ai|this app|this system|you)\\b/i)) {\n    data.category = 'system_feedback';\n    \n    if (text.match(/\\b(love|great|amazing|helpful|life.?changing|game.?changer)\\b/i)) {\n      data.system_sentiment = 'very positive';\n      data.nps_indicator = 9;\n    } else if (text.match(/\\b(like|good|useful|works)\\b/i)) {\n      data.system_sentiment = 'positive';\n      data.nps_indicator = 7;\n    } else if (text.match(/\\b(hate|terrible|useless|waste|sucks|annoying)\\b/i)) {\n      data.system_sentiment = 'very negative';\n      data.nps_indicator = 3;\n    }\n  }\n  \n  // Feature requests\n  if (text.match(/\\b(wish|want|need|should|could you|can you|would be nice)\\b/i)) {\n    data.category = 'feature_request';\n    data.request_type = 'enhancement';\n  }\n  \n  // Bug reports\n  if (text.match(/\\b(broken|bug|error|doesn't work|not working|crashed|glitch)\\b/i)) {\n    data.category = 'bug_report';\n    data.request_type = 'fix';\n  }\n  \n  // Success stories (LIQUID GOLD!)\n  if (text.match(/\\b(worked|helped|achieved|succeeded|finally|breakthrough|thanks to)\\b/i)) {\n    data.category = 'success_story';\n    data.impact_reported = true;\n  }\n  \n  // Transformation indicators (for brand pivot)\n  if (text.match(/\\b(transformed|changed my|inevitable|unstoppable|momentum|different person)\\b/i)) {\n    data.transformation_language = true;\n    data.brand_alignment = 'new_positioning';\n  } else if (text.match(/\\b(harsh|brutal|truth|called out|exposed)\\b/i)) {\n    data.brand_alignment = 'old_positioning';\n  }\n  \n  return data;\n}\n\nfunction extractBusinessModels(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Business model type\n  if (text.match(/\\b(subscription|recurring|monthly|saas|sub)\\b/i)) {\n    data.business_type = 'subscription';\n  } else if (text.match(/\\b(marketplace|platform|commission|take rate)\\b/i)) {\n    data.business_type = 'marketplace';\n  } else if (text.match(/\\b(freemium|free tier|premium|upgrade)\\b/i)) {\n    data.business_type = 'freemium';\n  } else if (text.match(/\\b(licensing|license|royalty|franchise)\\b/i)) {\n    data.business_type = 'licensing';\n  } else if (text.match(/\\b(advertising|ads|ad revenue|sponsors)\\b/i)) {\n    data.business_type = 'advertising';\n  } else if (text.match(/\\b(one time|single purchase|product sales?)\\b/i)) {\n    data.business_type = 'one_time_purchase';\n  }\n  \n  // Revenue model\n  if (text.match(/\\b(product sales?|selling products?)\\b/i)) data.revenue_model = 'product_sales';\n  else if (text.match(/\\b(service|consulting|done for you)\\b/i)) data.revenue_model = 'services';\n  else if (text.match(/\\b(subscription|recurring|monthly)\\b/i)) data.revenue_model = 'subscriptions';\n  else if (text.match(/\\b(advertising|ads|sponsored)\\b/i)) data.revenue_model = 'advertising';\n  \n  // Monthly revenue range\n  const moneyValue = parseMoneyValue(text);\n  if (moneyValue) {\n    if (moneyValue >= 100000) data.monthly_revenue_range = '$100k+';\n    else if (moneyValue >= 50000) data.monthly_revenue_range = '$50k-$100k';\n    else if (moneyValue >= 25000) data.monthly_revenue_range = '$25k-$50k';\n    else if (moneyValue >= 10000) data.monthly_revenue_range = '$10k-$25k';\n    else if (moneyValue >= 5000) data.monthly_revenue_range = '$5k-$10k';\n    else if (moneyValue >= 1000) data.monthly_revenue_range = '$1k-$5k';\n    else data.monthly_revenue_range = '<$1k';\n    data.confidence_level = 0.9;\n  }\n  \n  // Business stage\n  if (text.match(/\\b(idea|concept|planning|just started)\\b/i)) {\n    data.business_stage = 'idea';\n  } else if (text.match(/\\b(launched|live|production|released)\\b/i)) {\n    data.business_stage = 'launched';\n  } else if (text.match(/\\b(scaling|growing|mature|established)\\b/i)) {\n    data.business_stage = 'scaling';\n  }\n  \n  // Team size\n  const teamMatch = text.match(/(?:team of|team size).*?(\\d+)/i);\n  if (teamMatch) {\n    data.team_size = parseInt(teamMatch[1]);\n  }\n  \n  return data;\n}\n\nfunction extractBusinessProduct(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Product type\n  if (text.match(/\\b(mobile app|app|ios|android|smartphone)\\b/i)) {\n    data.product_type = 'mobile_app';\n  } else if (text.match(/\\b(web app|website|webapp|browser|online)\\b/i)) {\n    data.product_type = 'web_app';\n  } else if (text.match(/\\b(saas|software|platform|tool)\\b/i)) {\n    data.product_type = 'saas';\n  } else if (text.match(/\\b(api|integration|service|backend)\\b/i)) {\n    data.product_type = 'api';\n  }\n  \n  // Development stage\n  if (text.match(/\\b(idea|concept|planning|just started)\\b/i)) {\n    data.development_stage = 'idea';\n  } else if (text.match(/\\b(prototype|prototyping|mockup|wireframe)\\b/i)) {\n    data.development_stage = 'prototype';\n  } else if (text.match(/\\b(mvp|minimum viable|basic version|alpha)\\b/i)) {\n    data.development_stage = 'mvp';\n  } else if (text.match(/\\b(beta|testing|pre-launch)\\b/i)) {\n    data.development_stage = 'beta';\n  } else if (text.match(/\\b(launched|live|production|released)\\b/i)) {\n    data.development_stage = 'launched';\n  }\n  \n  // User feedback score\n  const feedbackMatch = text.match(/([0-9.]+)(?:\\/10|\\/5|\\s*stars?|\\s*rating)/i);\n  if (feedbackMatch) {\n    data.user_feedback_score = parseFloat(feedbackMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Technical debt\n  if (text.match(/\\b(technical debt|legacy|messy|refactor|rewrite)\\b/i)) {\n    data.technical_debt_level = 7;\n  } else if (text.match(/\\b(clean code|well architected|maintainable)\\b/i)) {\n    data.technical_debt_level = 2;\n  }\n  \n  // Product market fit\n  if (text.match(/\\b(perfect fit|great fit|love it|product market fit)\\b/i)) {\n    data.product_market_fit_score = 9;\n  } else if (text.match(/\\b(poor fit|struggling|not working|users leaving)\\b/i)) {\n    data.product_market_fit_score = 3;\n  }\n  \n  return data;\n}\n\nfunction extractBusinessAgency(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Service type\n  if (text.match(/\\b(marketing|seo|ppc|ads|social media|digital marketing)\\b/i)) {\n    data.service_type = 'marketing';\n  } else if (text.match(/\\b(design|ui|ux|graphic|branding|logo|creative)\\b/i)) {\n    data.service_type = 'design';\n  } else if (text.match(/\\b(development|dev|coding|website|web dev|app dev)\\b/i)) {\n    data.service_type = 'development';\n  } else if (text.match(/\\b(consulting|strategy|advisory|business consulting)\\b/i)) {\n    data.service_type = 'consulting';\n  }\n  \n  // Client count\n  const clientMatch = text.match(/(?:have|got|working with).*?(\\d+).*?clients?/i);\n  if (clientMatch) {\n    data.client_count = parseInt(clientMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Project value\n  const valueMatch = text.match(/(?:projects average|project value).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i);\n  if (valueMatch) {\n    data.average_project_value = parseMoneyValue(valueMatch[1]);\n  }\n  \n  // Pricing model\n  if (text.match(/\\b(hourly|per hour|hour|hrs)\\b/i)) {\n    data.pricing_model = 'hourly';\n  } else if (text.match(/\\b(project|fixed|flat fee)\\b/i)) {\n    data.pricing_model = 'project';\n  } else if (text.match(/\\b(retainer|monthly|recurring)\\b/i)) {\n    data.pricing_model = 'retainer';\n  }\n  \n  // Scope creep\n  if (text.match(/\\b(scope creep|always adding|never ends|keeps expanding)\\b/i)) {\n    data.scope_creep_frequency = 8;\n  } else if (text.match(/\\b(clear boundaries|good scope|well defined)\\b/i)) {\n    data.scope_creep_frequency = 2;\n  }\n  \n  return data;\n}\n\nfunction extractBusinessContent(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Content type\n  if (text.match(/\\b(video|youtube|yt|tiktok|reel|reels|shorts)\\b/i)) {\n    data.content_type = 'video';\n  } else if (text.match(/\\b(blog|article|post|writing|seo|content marketing)\\b/i)) {\n    data.content_type = 'blog';\n  } else if (text.match(/\\b(podcast|audio|spotify|apple podcasts)\\b/i)) {\n    data.content_type = 'podcast';\n  } else if (text.match(/\\b(newsletter|email|email marketing)\\b/i)) {\n    data.content_type = 'newsletter';\n  }\n  \n  // Platform\n  if (text.match(/\\b(youtube|yt)\\b/i)) data.platform = 'youtube';\n  else if (text.match(/\\b(instagram|ig|insta)\\b/i)) data.platform = 'instagram';\n  else if (text.match(/\\b(tiktok|tt)\\b/i)) data.platform = 'tiktok';\n  else if (text.match(/\\b(linkedin|li)\\b/i)) data.platform = 'linkedin';\n  else if (text.match(/\\b(facebook|fb)\\b/i)) data.platform = 'facebook';\n  \n  // Engagement rate\n  const engagementMatch = text.match(/([0-9.]+)%?\\s*(?:engagement|engage|engaging)/i);\n  if (engagementMatch) {\n    data.engagement_rate = parseFloat(engagementMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Follower count\n  const followerMatch = text.match(/([0-9,]+k?)\\s*(?:followers|subs|subscribers)/i);\n  if (followerMatch) {\n    let count = followerMatch[1].replace(/,/g, '');\n    if (count.includes('k')) {\n      count = parseFloat(count.replace('k', '')) * 1000;\n    }\n    data.follower_count = parseInt(count);\n  }\n  \n  // Posting frequency\n  if (text.match(/\\b(daily|every day|each day)\\b/i)) {\n    data.posting_frequency = 'daily';\n  } else if (text.match(/\\b(weekly|once a week|per week)\\b/i)) {\n    data.posting_frequency = 'weekly';\n  } else if (text.match(/\\b(monthly|once a month|per month)\\b/i)) {\n    data.posting_frequency = 'monthly';\n  }\n  \n  return data;\n}\n\nfunction extractBusinessEcommerce(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Product category\n  if (text.match(/\\b(physical|shipped|shipping|warehouse|3pl|fulfillment)\\b/i)) {\n    data.product_category = 'physical';\n  } else if (text.match(/\\b(digital|download|pdf|course|ebook|software)\\b/i)) {\n    data.product_category = 'digital';\n  } else if (text.match(/\\b(subscription box|monthly box|recurring box)\\b/i)) {\n    data.product_category = 'subscription_box';\n  }\n  \n  // Conversion rate\n  const conversionMatch = text.match(/([0-9.]+)%?\\s*(?:conversion|converting|convert)/i);\n  if (conversionMatch) {\n    data.conversion_rate = parseFloat(conversionMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // AOV\n  const aovMatch = text.match(/(?:aov|average order|order value).*?\\$?([0-9,]+(?:\\.[0-9]+)?)/i);\n  if (aovMatch) {\n    data.average_order_value = parseMoneyValue(aovMatch[1]);\n  }\n  \n  // Inventory\n  const inventoryMatch = text.match(/(\\d+)\\s*(?:products|items|sku|skus|listings)/i);\n  if (inventoryMatch) {\n    data.inventory_count = parseInt(inventoryMatch[1]);\n  }\n  \n  // Cart abandonment\n  const cartMatch = text.match(/([0-9.]+)%?\\s*(?:abandon|cart abandon|left cart)/i);\n  if (cartMatch) {\n    data.cart_abandonment_rate = parseFloat(cartMatch[1]);\n  }\n  \n  return data;\n}\n\nfunction extractBusinessOperations(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // Automation level (1-10)\n  if (text.match(/\\b(fully automated|completely automated|100% automated)\\b/i)) {\n    data.automation_level = 9;\n  } else if (text.match(/\\b(mostly automated|highly automated)\\b/i)) {\n    data.automation_level = 7;\n  } else if (text.match(/\\b(some automation|partially automated)\\b/i)) {\n    data.automation_level = 5;\n  } else if (text.match(/\\b(manual|no automation|all manual)\\b/i)) {\n    data.automation_level = 1;\n  }\n  \n  // System integrations\n  const integrationsMatch = text.match(/(\\d+)\\s*(?:integrations|tools|systems|connected|apps)/i);\n  if (integrationsMatch) {\n    data.system_integrations = parseInt(integrationsMatch[1]);\n  }\n  \n  // Error rate\n  const errorMatch = text.match(/([0-9.]+)%?\\s*(?:error|mistakes|wrong|failed)/i);\n  if (errorMatch) {\n    data.error_rate = parseFloat(errorMatch[1]);\n  }\n  \n  // Response time\n  const responseMatch = text.match(/([0-9.]+)\\s*(?:hours?|hrs?|minutes?|mins?)\\s*(?:response|reply)/i);\n  if (responseMatch) {\n    let time = parseFloat(responseMatch[1]);\n    if (text.includes('minute') || text.includes('min')) {\n      time = time / 60; // Convert to hours\n    }\n    data.customer_service_response_time_hours = time;\n  }\n  \n  // Backup systems\n  if (text.match(/\\b(backup|backups|disaster recovery|redundancy)\\b/i)) {\n    data.backup_systems_in_place = !text.match(/\\b(no backup|no backups|not backed up)\\b/i);\n  }\n  \n  return data;\n}\n\nfunction extractBusinessSaas(text, emotions) {\n  const data = {\n    user_input: text,\n    emotional_signals: emotions,\n    confidence_level: 0.5\n  };\n  \n  // MRR\n  const mrrMatch = text.match(/(?:mrr|monthly recurring).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i);\n  if (mrrMatch) {\n    data.monthly_recurring_revenue = parseMoneyValue(mrrMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // ARR\n  const arrMatch = text.match(/(?:arr|annual recurring).*?\\$?([0-9,]+(?:\\.[0-9]+)?k?)/i);\n  if (arrMatch) {\n    data.annual_recurring_revenue = parseMoneyValue(arrMatch[1]);\n  }\n  \n  // Subscribers\n  const subsMatch = text.match(/([0-9,]+k?)\\s*(?:subscribers|users|customers|paying|active)/i);\n  if (subsMatch) {\n    let count = subsMatch[1].replace(/,/g, '');\n    if (count.includes('k')) {\n      count = parseFloat(count.replace('k', '')) * 1000;\n    }\n    data.active_subscribers = parseInt(count);\n  }\n  \n  // Churn rate\n  const churnMatch = text.match(/([0-9.]+)%?\\s*(?:churn|cancel|churning|leaving)/i);\n  if (churnMatch) {\n    data.churn_rate = parseFloat(churnMatch[1]);\n    data.confidence_level = 0.9;\n  }\n  \n  // Trial conversion\n  const trialMatch = text.match(/([0-9.]+)%?\\s*(?:trial.*convert|convert.*trial)/i);\n  if (trialMatch) {\n    data.trial_to_paid_conversion = parseFloat(trialMatch[1]);\n  }\n  \n  // New signups\n  const signupMatch = text.match(/(\\d+)\\s*(?:new|fresh)?\\s*(?:signups|registrations|users)/i);\n  if (signupMatch) {\n    data.new_signups = parseInt(signupMatch[1]);\n  }\n  \n  return data;\n}\n\n// ===== MAIN ROUTER FUNCTION =====\nfunction routeMessage(input) {\n  // Match the exact n8n merge structure\n  const allInputs = $input.all();\n  \n  // Previous conversation from Postgres (position 0)\n  const previousData = allInputs[0]?.json || {};\n  const previousMessage = previousData.message || null;\n  const previousAIReply = previousData.ai_reply || null;\n  \n  // Current message from webhook (position 1)\n  const currentData = allInputs[1]?.json?.body || allInputs[1]?.json || {};\n  const message = currentData.message;\n  const userID = currentData.userID;\n  const sessionID = currentData.sessionID;\n  \n  // Handle empty\n  if (!message || message.trim() === '') {\n    return [{\n      table: \"unknown_interactions\",\n      operation: \"insert\",\n      data: {\n        user_input: message || '',\n        reason_unclassified: \"empty message\",\n        confidence_level: 1.0,\n        emotional_signals: []\n      }\n    }];\n  }\n  \n  // Clean and analyze\n  const cleanedMessage = cleanTypos(message.toLowerCase());\n  const emotions = extractEmotions(cleanedMessage);\n  const tables = detectTables(cleanedMessage);\n  \n  const results = [];\n  \n  // CRITICAL: Check if this is user feedback FIRST\n  const isFeedback = previousAIReply && (\n    message.match(/\\b(yes|no|ok|sure|won't|can't|tried|but|because|works|doesn't work|thanks|helpful)\\b/i) ||\n    message.includes('celeste') ||\n    message.length < 100 && tables.length === 0 // Short responses to AI are often feedback\n  );\n  \n  if (isFeedback) {\n    tables.push('user_feedback');\n  }\n  \n  // Always add recent_interactions\n  const primaryTable = tables[0] || 'general';\n  results.push({\n    table: \"recent_interactions\",\n    operation: \"insert\",\n    data: {\n      user_id: userID,\n      session_id: sessionID,\n      interaction_type: \"text-chat\",\n      content: message,\n      category: primaryTable,\n      metadata: {\n        triggers: tables,\n        ripples: tables.slice(1) || [],\n        has_context: !!previousAIReply,\n        is_feedback: isFeedback\n      },\n      emotional_signals: emotions,\n      confidence_level: 1.0\n    }\n  });\n  \n  // Handle contextual responses\n  if (previousAIReply) {\n    // Pure number with context\n    if (/^\\d+$/.test(message.trim())) {\n      if (previousAIReply.match(/how many|number of|count/i)) {\n        if (previousAIReply.includes('deals') || previousAIReply.includes('sales')) {\n          results.push({\n            table: \"business:sales\",\n            operation: \"insert\",\n            data: {\n              user_input: message,\n              ai_context: previousAIReply,\n              deals_count: parseInt(message),\n              confidence_level: 0.95,\n              emotional_signals: emotions\n            }\n          });\n        } else if (previousAIReply.includes('coffee') || previousAIReply.includes('cups')) {\n          results.push({\n            table: \"health\",\n            operation: \"insert\",\n            data: {\n              user_input: message,\n              ai_context: previousAIReply,\n              caffeine_intake: parseInt(message),\n              confidence_level: 0.95,\n              emotional_signals: emotions\n            }\n          });\n        }\n      }\n      \n      // Still route to user_feedback for tracking\n      if (isFeedback) {\n        results.push({\n          table: \"user_feedback\",\n          operation: \"insert\",\n          data: extractUserFeedback(message, emotions, sessionID, previousAIReply)\n        });\n      }\n      \n      return results;\n    }\n    \n    // Yes/No responses\n    if (message.toLowerCase().match(/^(yes|no|yeah|nope|yep|nah|ok|okay|sure)$/)) {\n      // Always capture as feedback\n      results.push({\n        table: \"user_feedback\",\n        operation: \"insert\",\n        data: extractUserFeedback(message, emotions, sessionID, previousAIReply)\n      });\n      \n      // Also route to specific table if context is clear\n      if (previousAIReply.includes('workout') || previousAIReply.includes('gym')) {\n        results.push({\n          table: \"fitness\",\n          operation: \"insert\",\n          data: {\n            user_input: message,\n            ai_context: previousAIReply,\n            missed_planned_workout: message.match(/no|nope|nah/i) ? true : false,\n            confidence_level: 0.9,\n            emotional_signals: emotions\n          }\n        });\n      }\n      \n      return results;\n    }\n    \n    // \"Because\" responses - ALWAYS feedback gold\n    if (message.toLowerCase().startsWith('because') || message.includes(' because ')) {\n      results.push({\n        table: \"user_feedback\",\n        operation: \"insert\",\n        data: {\n          ...extractUserFeedback(message, emotions, sessionID, previousAIReply),\n          category: 'reasoning',\n          has_context: true,\n          confidence_level: 1.0\n        }\n      });\n      \n      // Also extract to relevant domain tables\n      const contextTables = detectTables(previousMessage + ' ' + message);\n      for (const table of contextTables) {\n        if (table !== 'user_feedback') {\n          results.push({\n            table: table,\n            operation: \"insert\",\n            data: {\n              user_input: message,\n              context_from_previous: previousMessage,\n              reasoning_provided: message,\n              emotional_signals: emotions,\n              confidence_level: 0.7\n            }\n          });\n        }\n      }\n      \n      return results;\n    }\n  }\n  \n  // No triggers found\n  if (tables.length === 0) {\n    results.push({\n      table: \"unknown_interactions\",\n      operation: \"insert\",\n      data: {\n        user_input: message,\n        reason_unclassified: \"no triggers found\",\n        potential_categories: [],\n        ai_context: previousAIReply,\n        emotional_signals: emotions,\n        confidence_level: 0.3\n      }\n    });\n    return results;\n  }\n  \n  // Route to all detected tables\n  for (const table of tables) {\n    let data = {};\n    \n    switch(table) {\n      case 'business:sales':\n        data = extractBusinessSales(message, emotions);\n        break;\n      case 'business:networking':\n        data = extractBusinessNetworking(message, emotions);\n        break;\n      case 'business:advertisments':\n        data = extractBusinessAdvertisements(message, emotions);\n        break;\n      case 'business:models':\n        data = extractBusinessModels(message, emotions);\n        break;\n      case 'business:product':\n        data = extractBusinessProduct(message, emotions);\n        break;\n      case 'business:agency':\n        data = extractBusinessAgency(message, emotions);\n        break;\n      case 'business:content':\n        data = extractBusinessContent(message, emotions);\n        break;\n      case 'business:ecommerce':\n        data = extractBusinessEcommerce(message, emotions);\n        break;\n      case 'business:operations':\n        data = extractBusinessOperations(message, emotions);\n        break;\n      case 'business:saas':\n        data = extractBusinessSaas(message, emotions);\n        break;\n      case 'health':\n        data = extractHealth(message, emotions);\n        break;\n      case 'fitness':\n        data = extractFitness(message, emotions);\n        break;\n      case 'routine':\n        data = extractRoutine(message, emotions);\n        break;\n      case 'goals':\n        data = extractGoals(message, emotions);\n        break;\n      case 'emotions':\n        data = extractEmotionsTable(message, emotions);\n        break;\n      case 'family':\n        data = extractFamily(message, emotions);\n        break;\n      case 'leverage':\n        data = extractLeverage(message, emotions);\n        break;\n      case 'common_problems':\n        data = extractCommonProblems(message, emotions);\n        break;\n      case 'performance':\n        data = extractPerformance(message, emotions);\n        break;\n      case 'user_feedback':\n        data = extractUserFeedback(message, emotions, sessionID, previousAIReply);\n        break;\n      default:\n        data = {\n          user_input: message,\n          emotional_signals: emotions,\n          confidence_level: 0.5\n        };\n    }\n    \n    // Add context if available\n    if (previousAIReply && !data.ai_context) {\n      data.ai_context = previousAIReply;\n    }\n    \n    results.push({\n      table: table,\n      operation: \"insert\",\n      data: data\n    });\n  }\n  \n  return results;\n}\n\n// ===== EXPORT FOR N8N =====\n// No need for complex handling - routeMessage now expects the merged structure\nreturn routeMessage($input);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        580,
        -580
      ],
      "id": "40b02cea-85ab-4650-9669-a0e05d04ddd3",
      "name": "DETERMINISTIC ROUTER V3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://ventruk.app.n8n.cloud/webhook/async-processor",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"userID\": \"{{ $json.user_id }}\",\n  \"message\": \"{{ $json.message }}\",\n  \"ai_reply\": \"{{ $json.ai_reply }}\",\n  \"sessionID\": \"{{ $json.session_id || $json.id }}\",\n  \"timestamp\": \"{{ $json.created_at }}\"\n}",
        "options": {
          "batching": {
            "batch": {
              "batchSize": 1
            }
          },
          "allowUnauthorizedCerts": false,
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true,
              "responseFormat": "json"
            }
          },
          "timeout": 5000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2560,
        -520
      ],
      "id": "89d8a843-5f7a-4b35-85b9-46960a6af97f",
      "name": "Trigger Async Processing",
      "disabled": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "content": "",
        "height": 680,
        "width": 220,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2500,
        -580
      ],
      "id": "4495d4a0-a038-4d80-9e38-6d5a8cbd53d8",
      "name": "Sticky Note19"
    },
    {
      "parameters": {
        "content": "## Pattern Sending",
        "height": 120,
        "width": 220,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2500,
        80
      ],
      "id": "20b5d991-9694-400b-910f-748d37a09198",
      "name": "Sticky Note20"
    },
    {
      "parameters": {
        "content": "## 🗑️🗑️🗑️🗑️🗑️🗑️ \n   UNKNOWN",
        "height": 220,
        "width": 170,
        "color": 7
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1280,
        1920
      ],
      "id": "9cdad532-f5e0-47bd-b452-7a78ef3516df",
      "name": "Sticky Note22"
    }
  ],
  "connections": {
    "Async Entry1": {
      "main": [
        [
          {
            "node": "Postgres",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "DETERMINISTIC ROUTER V3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Recent Interactions": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Summary": {
      "main": [
        [
          {
            "node": "Trigger Async Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Create Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Health": {
      "main": [
        [
          {
            "node": "Insert Health",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Goals": {
      "main": [
        [
          {
            "node": "Insert Goals",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Emotions": {
      "main": [
        [
          {
            "node": "Insert Emotions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Family": {
      "main": [
        [
          {
            "node": "Insert Family",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Leverage": {
      "main": [
        [
          {
            "node": "Insert Leverage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Common Problems": {
      "main": [
        [
          {
            "node": "Insert Common Problems1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Performance": {
      "main": [
        [
          {
            "node": "Insert Performance1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Business Networking": {
      "main": [
        [
          {
            "node": "Insert Business Networking",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Business Advertisments": {
      "main": [
        [
          {
            "node": "Insert Business Advertisments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Tables1": {
      "main": [
        [
          {
            "node": "Prepare Recent Interactions",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Sales",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Networking",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Advertisments",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Fitness",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Health",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Emotions",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Family",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Leverage",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Goals",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Routine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Common Problems",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare User Feedback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Performance",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Finance",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Product",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Operations",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Agency",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Content",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business SaaS",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Models",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Business Ecom",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Unknown Tables5",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Unknown Tables5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Common Problems1": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Insert Performance1": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Prepare Business Sales": {
      "main": [
        [
          {
            "node": "Insert Business Sales",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Sales": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Insert Business Networking": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Insert Fitness": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Insert Business Advertisments": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Prepare Fitness": {
      "main": [
        [
          {
            "node": "Insert Fitness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Health": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Insert Emotions": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "Insert Family": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 7
          }
        ]
      ]
    },
    "Insert Leverage": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 8
          }
        ]
      ]
    },
    "Prepare User Feedback": {
      "main": [
        [
          {
            "node": "Insert User Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Goals": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 9
          }
        ]
      ]
    },
    "Prepare Routine": {
      "main": [
        [
          {
            "node": "Insert Routine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Routine": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Recent Interactions": {
      "main": [
        [
          {
            "node": "Insert Recent Interactions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert User Feedback": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Insert Unknown Table": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Handle Unknown Tables5": {
      "main": [
        [
          {
            "node": "Insert Unknown Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Business Models": {
      "main": [
        [
          {
            "node": "Insert Business Models",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Business Ecom": {
      "main": [
        [
          {
            "node": "Insert Business Ecom",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Ecom": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Insert Business Models": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Business SaaS": {
      "main": [
        [
          {
            "node": "Insert Business SaaS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business SaaS": {
      "main": [
        [
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Business Content": {
      "main": [
        [
          {
            "node": "Insert Business Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Content": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 9
          }
        ]
      ]
    },
    "Prepare Business Agency": {
      "main": [
        [
          {
            "node": "Insert Business Agency",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Agency": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 8
          }
        ]
      ]
    },
    "Prepare Business Operations": {
      "main": [
        [
          {
            "node": "Insert Business Operations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Operations": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 7
          }
        ]
      ]
    },
    "Prepare Business Product": {
      "main": [
        [
          {
            "node": "Insert Business Product",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Product": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "Prepare Business Finance": {
      "main": [
        [
          {
            "node": "Insert Business Finance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Business Finance": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Merge3",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "DETERMINISTIC ROUTER V3": {
      "main": [
        [
          {
            "node": "Route Tables1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "068fcf99ddb3fd716c0b9e3d012c519dd8a4dfdbe854073434d3ac70e6f4cf11"
  }
}